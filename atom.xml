<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水无痕</title>
  
  <subtitle>side-dish-bird.github.io</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-25T15:16:44.851Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水无痕</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql优化</title>
    <link href="http://yoursite.com/2020/10/25/mysql%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/10/25/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2020-10-25T12:27:29.000Z</published>
    <updated>2020-10-25T15:16:44.851Z</updated>
    
    <content type="html"><![CDATA[<h5 id="建表原则"><a href="#建表原则" class="headerlink" title="建表原则"></a><strong>建表原则</strong></h5><h5 id="表的优化与列类型选择"><a href="#表的优化与列类型选择" class="headerlink" title="表的优化与列类型选择"></a><em>表的优化与列类型选择</em></h5><h5 id="表的优化"><a href="#表的优化" class="headerlink" title="表的优化"></a>表的优化</h5><ol><li><p>定长与变长分离</p><p>如：id  int 占4个字节，char(4)占4个字符长度，也是定长，time。即每一单元值占的字节是固定的</p><p>核心且常用字段，宜建成定长，放在一张表</p><p>而varchar，text,blob这种变长字段，适合单放一张表，用主键与核心表关联起来</p></li><li><p>常用字段和不常用字段要分离</p><p>需要结合网站具体的业务来分析，分析字段的查询场景，查询频率低的字段，单拆出来</p></li><li><p>在1对多，需要关联统计的字段，添加冗余字段</p><p>例：有栏目表和文章表俩表，现要求显示栏目下的文章个数</p><p>方法一：俩表联查。 //比较消耗资源</p><p>方法二：在栏目表添加一个字段用来记录文章数，添加一个文章则 该字段+1//冗余字段，但效率高了</p></li></ol><h5 id="列的选择原则"><a href="#列的选择原则" class="headerlink" title="列的选择原则"></a>列的选择原则</h5><ol><li><p>字段类型优先级 。整型 &gt; date, time &gt; enum , char &gt; varchar &gt; blob, text</p><p>列的特点分析：</p><p>整型：定长 没有国家，地区之分 没有字符集的差异</p><p>​            比如：tinyint  1,2,3,4,5, &lt;–&gt; char(1) a,b,c,d,e</p><p>​                        从空间上，都是占1个字节，但是order by 排序，前者快</p><p>​                       原因：后者需要考虑字符集与校对集(就是排序规则)</p></li></ol><p>​        time: 定长  运算快 节省空间 考虑时区  写sql时不方便 where &gt; ‘2005-10-12’;</p><p>​       enum:能起约束值的目的，内部用整型来存储，但与char联查时，内部要经历串与值的变化</p><p>​       char: 定长 考虑字符集和排序校对集<br>​       varchar: 不定长 要考虑字符集的转换与排序时的校对集，速度慢</p><p>​       text/blob ：无法使用内存临时表  排序等操作只能在磁盘上进行</p><p>​        <em>附：关于date time 的选择，直接选择 int  unsigned not null 存储时间戳</em></p><ol start="2"><li><p>够用就行，不要慷慨(如smallint varchar(N))</p><p>原因：大的字段浪费内存，影响速度</p><p>以年龄为例：tinyint  unsigned not null 可以存储255岁，足够，用int 则浪费3个字节</p><p>以varchar(100),varchar(300)存储的内容相同，但在表联查时varchar(300)要花更多的时间</p></li><li><p>尽量避免用null</p><p>null不利于索引，要用特殊的字节来标注。在磁盘上占据的空间其实更大</p></li></ol><h5 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h5><p>​      何为索引？答：一种使得查询高效的数据结构</p><p>   索引类型：</p><ol><li>btree索引</li></ol><p>​    名叫btree索引，大的方面看，都用的平衡树，但具体的实现上，各引擎稍有不同</p><p>​    比如严格的说：NDB引擎，使用的是T-tree</p><p>​     myisam  innodb中默认用B-tree索引</p><p>​     但抽象一下，B-tree系统可理解为’排好序的快速查找结构’. </p><ol start="2"><li><p>hash索引</p><p>在memory表里默认是hash索引，hash的理论查询时间复杂度为0</p><p>疑问：既然hash的查找如此高效，为什么不都用hash索引？</p><p>答：1：hash函数计算后的结构是随机的，如果在磁盘上放置数据，比如主键为id为例,那么随着id的增长，id对应的行，在磁盘上随机放置</p><p>2：没法对范围查询进行优化(id随机没有规律造成的)</p><p>3：无法利用前缀索引，比如在btree中，field列的值”helloworld” 并加索引，查询xx=helloword自然可以利用索引。xx=hello也可以利用索引(左前缀索引)</p><p>4:排序也无法优化</p><p>5：必须回行，就是说，通过索引拿到数据位置，必须回到表中取数据</p></li></ol><p>btree索引的常见误区</p><p>​     在where条件常用的列上都加索引</p><p>​     例：where cat_id=3 and price&gt;100 //查询第3个栏目，100元以上的商品</p><p>​     误：cat_id 和price 上都加上索引</p><p>​    错：只能用上cat_id 或 price 索引，因为是独立的索引，同时只能用上一个</p><p>   在多列上建立索引后，查询哪个列，索引都将发挥作用</p><p>​    误：多列索引上，索引发挥作用，需要满足做前缀要求</p><p>​    以index(a,b,c)为例，注意和顺序有关</p><p>​    a,b,c上的索引是否生效跟前一个有关，c索引依靠b,b索引依靠a。如果b没使用上则c索引也不生效。b使用上一部分索引c也同样不生效</p><p><code>mysql&gt;explain select * from table where id=3 \G</code> 查看索引使用情况</p><p>一道面试题：</p><p>有商品表，有主键goods_id，栏目列cat_id，价格price</p><p>说：在价格列上已经加了索引，但按价格查询还是很慢</p><p>问可能是什么原因，怎么解决？</p><p>答：在实际场景中，一个电商网站的商品分类很多，直接在所有商品中，按价格查商品，是极少的，一般客户都来到分类下，然后再查</p><p>改正：去掉单独的price列的索引，加(cat_id,price)复合索引，再查询</p><h5 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h5><p>查询大原则：</p><p>​     sql语句优化</p><p>​     sql语句的时间花在哪里？</p><p>​      答：等待时间，执行时间</p><p>​     这两个时间并非孤立的，如果单条语句执行的快了，对其它语句的锁定的也就少了</p><p>​     所以我们来分析如何降低执行时间。</p><p>sql语句的执行时间，又花在哪了？</p><p>​      答：查找—&gt;沿着索引查找，慢者可能全表扫描</p><p>​              取出—&gt;查到行后，把数据取出来</p><p>如何查询快？</p><p>​      查询快：联合索引的顺序，区分度，索引长度</p><p>​      取得快：索引覆盖</p><p>​       传输的少，更少的行和列</p><p>简述：explain：查看索引的使用情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   explain select goods_id,goods_name from ecs_goods \G</span><br><span class="line">          id:1</span><br><span class="line"> select_type:simple     &#x2F;&#x2F;简单查询,没有子查询</span><br><span class="line">       table:ecs_goods  &#x2F;&#x2F;表名</span><br><span class="line">       type:ALL        &#x2F;&#x2F;扫描类型,all是扫描了所有</span><br><span class="line">possible_keys:NULL     &#x2F;&#x2F;可能用到的索引</span><br><span class="line">        key:NULL       &#x2F;&#x2F;真正用到的索引</span><br><span class="line">    key_len:NULL       &#x2F;&#x2F;使用的索引的最大长度</span><br><span class="line">        ref:NULL       &#x2F;&#x2F;引用关系</span><br><span class="line">       rows:33         &#x2F;&#x2F;本次要查出的行数</span><br><span class="line">       Extra:</span><br></pre></td></tr></table></figure><h5 id="强制使用索引：不推荐使用"><a href="#强制使用索引：不推荐使用" class="headerlink" title="强制使用索引：不推荐使用"></a>强制使用索引：不推荐使用</h5><p>​     use index(primary)强制使用主键索引<br>​    select id from area use index(primary) where pid=69;</p><h5 id="limit及翻页优化"><a href="#limit及翻页优化" class="headerlink" title="limit及翻页优化"></a>limit及翻页优化</h5><p>   limit offset,N  当offset非常大时,效率极低<br>   原因是mysql并不是跳过 offset行,然后单取 N 行,而是取offset+N行,返回放弃前offset行,返回N行<br>   效率较低,当offset越大时,效率越低。</p><p>   优化：<br>     1.从业务上解决<br>       办法：不允许翻过100页<br>       以百度为例,一般翻页到70页左右<br>     2.不用offset 用条件查询<br>        例：<br>         <code>mysql&gt;select id,name from lx_com limit 5000000,10;</code><br>       改为：<br>        <code>mysql&gt;select id,name from lx_com where id&gt;5000000 limit 10;</code><br>     但有个弊端,数据不能删除,id得保持。如果非要物理删除,还要用offset精确查询,还不限制用户分页怎么办？<br>      分析：优化思路是不查,少查,查索引,少取列<br>      我们现在必须要查,则只查索引,不查数据,得到id,再用id去查具体条目,这种技巧就是延迟关联<br>     <code>mysql&gt;select id,name from lx_com inner join(select id from lx_com limit 5000000,10)as tmp on lx_com.id=tmp.id;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;建表原则&quot;&gt;&lt;a href=&quot;#建表原则&quot; class=&quot;headerlink&quot; title=&quot;建表原则&quot;&gt;&lt;/a&gt;&lt;strong&gt;建表原则&lt;/strong&gt;&lt;/h5&gt;&lt;h5 id=&quot;表的优化与列类型选择&quot;&gt;&lt;a href=&quot;#表的优化与列类型选择&quot; class=
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2020/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-22T14:53:22.000Z</published>
    <updated>2020-10-22T15:28:34.504Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h4><p>答：经典场景的经典解决方法<br>模式是因为语言不够灵活，不能适应复杂的场景，而想出的方法</p><h5 id="简单工厂："><a href="#简单工厂：" class="headerlink" title="简单工厂："></a>简单工厂：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Mysql&#123;&#125;</span><br><span class="line">class Sqlite&#123;&#125;</span><br><span class="line"> &#x2F;&#x2F;设置一个工厂类，创建需要的类的对象</span><br><span class="line">class Factory&#123;</span><br><span class="line">public static function getDB($type)&#123;</span><br><span class="line">         if($type&#x3D;&#x3D;&quot;Mysql&quot;)&#123;</span><br><span class="line">             return new Mysql();</span><br><span class="line">         &#125;else if($type&#x3D;&#x3D;&quot;Sqlite&quot;)&#123;</span><br><span class="line">             return new Sqlite();</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             throw new Exception(&quot;sorry&quot;,1);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取DB对象</span><br><span class="line">print_r(Factory::getDB(&quot;Mysql&quot;));</span><br></pre></td></tr></table></figure><h5 id="抽象工厂："><a href="#抽象工厂：" class="headerlink" title="抽象工厂："></a>抽象工厂：</h5><p>开闭原则：应该对类的增加开放，对类的修改闭合。就是说尽量增加类，不要修改类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Mysql&#123;&#125;</span><br><span class="line">class Sqlite&#123;&#125;</span><br><span class="line">class MyPDO&#123;&#125;</span><br><span class="line">interface Factory&#123;</span><br><span class="line">public static function getDB();</span><br><span class="line">&#125;</span><br><span class="line">class MysqlFactory implements Factory&#123;</span><br><span class="line">public static function getDB()&#123;</span><br><span class="line"> return new Mysql();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class SqliteFactory implements Factory&#123;</span><br><span class="line">public static function getDB()&#123;</span><br><span class="line"> return new Sqlite();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyPDOFactory implements Factory&#123;</span><br><span class="line">public static function getDB()&#123;</span><br><span class="line"> return new MyPDO();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;配置文件</span><br><span class="line">$fact&#x3D;&#39;MyPDOFactory&#39;;</span><br><span class="line">$db&#x3D;MyPDOFactory::getDB();</span><br><span class="line">print_r($db);</span><br></pre></td></tr></table></figure><h5 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Single&#123;</span><br><span class="line">protected static $flag&#x3D;null;</span><br><span class="line">&#x2F;&#x2F;禁止外部new操作</span><br><span class="line">protected function __construct()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;提供一个对外接口，创建new对象</span><br><span class="line">public static function getIns()&#123;</span><br><span class="line">  if(self::$flag&#x3D;&#x3D;null)&#123;</span><br><span class="line">   self::$flag&#x3D;new self();</span><br><span class="line">  &#125;</span><br><span class="line">  return self::$flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h5><p>当一个对象的状态发生改变时，依赖他的对象会全部收到通知，并自动更新。<br>场景：一个事件发生后，要执行一连串更新操作，传统的编程方式，就是在事件的代码之后直接加入处理逻辑，当更新的逻辑增多之后，代码会变得难以维护，这种方式是耦合的，侵入式的，增加新的逻辑需要改变事件主题的代码，观察者模式实现了低耦合，非侵入式的通知与更新机制</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> 事件生产类</span><br><span class="line">   abstract class EventGenerator&#123;</span><br><span class="line">     private $obServers&#x3D;[];</span><br><span class="line">     &#x2F;&#x2F;增加观察者</span><br><span class="line">     public function add(obServer $obServer)&#123;</span><br><span class="line">        $this-&gt;$obServers[]&#x3D;$obServer;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;事件通知</span><br><span class="line">     public function notify()&#123;</span><br><span class="line">       foreach($this-&gt;$obServers as $obServer)&#123;</span><br><span class="line">         $obServer-&gt;update();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F;观察者接口类</span><br><span class="line">interface ObServer&#123;</span><br><span class="line"> public function update($event_info&#x3D;null);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;观察者1</span><br><span class="line">class ObServer1 implements ObServer&#123;</span><br><span class="line">public function update($event_info&#x3D;null)&#123;</span><br><span class="line">       echo &quot;观察者1 收到执行通知 执行完毕 ！\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;观察者2</span><br><span class="line">class ObServer2 implements ObServer&#123;</span><br><span class="line">public function update($event_info&#x3D;null)&#123;</span><br><span class="line">  echo &quot;观察者2 收到执行通知 执行完毕 ！\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;事件</span><br><span class="line"> class Event extends EventGenrator&#123;</span><br><span class="line">    public function trigger()&#123;</span><br><span class="line">      &#x2F;&#x2F;通知观察者</span><br><span class="line">      $this-&gt;notify();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;创建一个事件</span><br><span class="line"> $event&#x3D;new Event();</span><br><span class="line"> &#x2F;&#x2F;为事件增加旁观者</span><br><span class="line"> $event-&gt;add(new ObServer1());</span><br><span class="line"> $event-&gt;add(new ObServer2());</span><br><span class="line">&#x2F;&#x2F;执行事件 通知旁观者</span><br><span class="line">$event-&gt;trigger();</span><br></pre></td></tr></table></figure><h5 id="责任链模式："><a href="#责任链模式：" class="headerlink" title="责任链模式："></a>责任链模式：</h5><p>包含了一些命令对象和一些处理对象，每个处理对象决定它能处理那些命令对象，他也知道应该把自己不能处理的命令对象交下一个处理对象，该模式还描述了往该链添加新的处理对象的方法<br>实例情景：<br>   当用户发布一个帖子时：<br>       如果版主可以决定，就版主处理<br>       如果版主不能决定，就交给上一级管理员处理<br>       如果管理员不能决定，就交给上一级治安部们处理；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class banzhu&#123;</span><br><span class="line">protected $level&#x3D;1;&#x2F;&#x2F;当前级别为1</span><br><span class="line">    protected $top&#x3D;&quot;admin&quot;;&#x2F;&#x2F;高一级的处理</span><br><span class="line">public function process($lv&#x3D;1)&#123;</span><br><span class="line"> if($lv&lt;&#x3D;$this-&gt;level)&#123;</span><br><span class="line">    echo &quot;版主删帖&quot;.&#39;&lt;br&#x2F;&gt;&#39;;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line">        $top&#x3D;new $this-&gt;top;</span><br><span class="line">        $top-&gt;process($lv);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class admin&#123;</span><br><span class="line">protected $level&#x3D;2;</span><br><span class="line">protected $top&#x3D;&quot;police&quot;;</span><br><span class="line">public function process($lv &#x3D;2)&#123;</span><br><span class="line">  if($lv&lt;&#x3D;$this-&gt;$level)&#123;</span><br><span class="line">    echo &quot;管理员冻结账号&quot;.&#39;&lt;br&#x2F;&gt;&#39;;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    $top&#x3D;new $this-&gt;top;</span><br><span class="line">    $top-&gt;process($lv);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class police&#123;</span><br><span class="line">public function process($lv&#x3D;3)&#123;</span><br><span class="line">  echo &quot;治安部门参与治理&quot;.&#39;&lt;br&#x2F;&gt;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$lv&#x3D;isset($_GET[&#39;lv&#39;])？$_GET[&#39;lv&#39;]:1;</span><br><span class="line">$cls&#x3D;new banzhu();</span><br><span class="line">$cls-&gt;process($lv);</span><br></pre></td></tr></table></figure><h5 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h5><p>将一组特定的行为和算法封装成类，以适应某些特定的上下文环境，并让他们可以相互替换，这种模式就是策略模式<br>简单理解就是 有n个做法供你选择，根据你的需要选择某个策略得到结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class NorthCook&#123;</span><br><span class="line">public function fan()&#123;</span><br><span class="line"> return &quot;面条&quot;；</span><br><span class="line">&#125;</span><br><span class="line">public function cai()&#123;</span><br><span class="line"> return &#39;炒菜&#39;；</span><br><span class="line">&#125;</span><br><span class="line">public function tang()&#123;</span><br><span class="line"> return &quot;蛋花汤&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class SouthCook&#123;</span><br><span class="line">public function fan()&#123;</span><br><span class="line"> return &#39;米饭&#39;;</span><br><span class="line">&#125;</span><br><span class="line">public function cai()&#123;</span><br><span class="line">  return &#39;炒菜+奶油&#39;;</span><br><span class="line">&#125;</span><br><span class="line">public function tang()&#123;</span><br><span class="line"> return &#39;海鲜汤&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class FD&#123;</span><br><span class="line">protected $fanCreateor&#x3D;null;</span><br><span class="line">protected $caiCreateor&#x3D;null;</span><br><span class="line">protected $tangCreateor&#x3D;null;</span><br><span class="line">public funciton __construct($f,$c,$tang)&#123;</span><br><span class="line"> $this-&gt;fanCreateor&#x3D;$f;</span><br><span class="line"> $this-&gt;caiCreateor&#x3D;$c;</span><br><span class="line"> $this-&gt;tangCreateor&#x3D;$tang;</span><br><span class="line">&#125;</span><br><span class="line">public function createFan()&#123;</span><br><span class="line"> return $this-&gt;fanCreateor-&gt;fan();</span><br><span class="line">&#125;</span><br><span class="line">public function createCai()&#123;</span><br><span class="line"> return $this-&gt;caiCreateor-&gt;cai();</span><br><span class="line">&#125;</span><br><span class="line">public function createTang()&#123;</span><br><span class="line"> return $this-&gt;tangCreateor-&gt;tang();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$fd&#x3D;new FD(new NorthCook(),new NorthCook(),new SouthCook);</span><br><span class="line">echo $fd-&gt;createFan() , &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo $fd-&gt;createTang() , &quot;&lt;br &#x2F;&gt;&quot;;</span><br></pre></td></tr></table></figure><h5 id="装饰器模式："><a href="#装饰器模式：" class="headerlink" title="装饰器模式："></a>装饰器模式：</h5><p>动态的给一个对象添加一些额外的职责，就增加功能来说，装饰器比生成子类更加灵活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Art&#123;</span><br><span class="line">protected $content;</span><br><span class="line">public function __construct($content)&#123;</span><br><span class="line">      $this-&gt;content&#x3D;$content;</span><br><span class="line">&#125;</span><br><span class="line">public function decorator()&#123;</span><br><span class="line"> return $this-&gt;content;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Artdec extends Art&#123;</span><br><span class="line">protected $art&#x3D;null;</span><br><span class="line">public funciton __construct($art)&#123;</span><br><span class="line"> $this-&gt;art&#x3D;$art;</span><br><span class="line">&#125;</span><br><span class="line">public function decorator()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class SeoArt extends Artdec&#123;</span><br><span class="line">public funciton decorator()&#123;</span><br><span class="line"> return $this-&gt;art-&gt;decorator(). &#39; SEO keywords&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class AdArt extends Artdec&#123;</span><br><span class="line">public function decorator()&#123;</span><br><span class="line"> return $this-&gt;art-&gt;decorator().&#39;广告内容&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$art&#x3D;new Art(&#39;这是一篇普通文件&#39;);</span><br><span class="line">$art&#x3D;new SeoArt($art);</span><br><span class="line">$art&#x3D;new AdArt($art);</span><br><span class="line">echo $art-&gt;decorator() , &quot;&lt;br&gt;&quot;;</span><br></pre></td></tr></table></figure><h5 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h5><p>将一个类的接口，转换成客户期望的另一个类的接口，适配器让原本接口不兼容的类可以合作无间<br>目标(Target)角色：定义客户端使用的与特定领域相关的接口，这也就是我们所期待得到的<br>源(Adaptee)角色：需要进行适配的接口<br>适配器(Adapter)角色：对Adaptee的接口与Target接口进行适配；适配器是本模式的核心，适配器把源接口转换成目标接口，此角色为具体类。</p><p>类适配器使用的是继承：<br>类适配器采用“多继承”的实现方式，带来了不良的高耦合，所以一般不推荐使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;目标角色</span><br><span class="line">interface Target &#123; </span><br><span class="line">    &#x2F;&#x2F; 源类也有的方法1</span><br><span class="line">    public function sampleMethod1();</span><br><span class="line">    &#x2F;&#x2F; 源类没有的方法2</span><br><span class="line">    public function sampleMethod2();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 源角色</span><br><span class="line">class Adaptee &#123;</span><br><span class="line">     &#x2F;&#x2F;源类含有的方法</span><br><span class="line">    public function sampleMethod1() &#123;</span><br><span class="line">        echo &#39;Adaptee sampleMethod1 &lt;br &#x2F;&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 类适配器角色</span><br><span class="line">class Adapter extends Adaptee implements Target &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 源类中没有sampleMethod2方法，在此补充</span><br><span class="line">    public function sampleMethod2() &#123;</span><br><span class="line">        echo &#39;Adapter sampleMethod2 &lt;br &#x2F;&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> class Client &#123;</span><br><span class="line">&#x2F;&#x2F; Main program.</span><br><span class="line">    public static function main() &#123;</span><br><span class="line">        $adapter &#x3D; new Adapter();</span><br><span class="line">        $adapter-&gt;sampleMethod1();</span><br><span class="line">        $adapter-&gt;sampleMethod2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象适配器使用的是委派<br>对象适配器采用“对象组合”的方式，更符合松耦合精神</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;目标角色</span><br><span class="line">interface Target &#123; </span><br><span class="line">    &#x2F;&#x2F; 源类也有的方法1</span><br><span class="line">    public function sampleMethod1();</span><br><span class="line">    &#x2F;&#x2F; 源类没有的方法2</span><br><span class="line">    public function sampleMethod2();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 源角色</span><br><span class="line">class Adaptee &#123;</span><br><span class="line">     &#x2F;&#x2F;源类含有的方法</span><br><span class="line">    public function sampleMethod1() &#123;</span><br><span class="line">        echo &#39;Adaptee sampleMethod1 &lt;br &#x2F;&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类适配器角色</span><br><span class="line">class Adapter implements Target &#123;</span><br><span class="line">    private $_adaptee;</span><br><span class="line">    public function __construct(Adaptee $adaptee) &#123;</span><br><span class="line">        $this-&gt;_adaptee &#x3D; $adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F; 委派调用Adaptee的sampleMethod1方法</span><br><span class="line">    public function sampleMethod1() &#123;</span><br><span class="line">        $this-&gt;_adaptee-&gt;sampleMethod1();</span><br><span class="line">    &#125;</span><br><span class="line">   &#x2F;&#x2F;源类中没有sampleMethod2方法，在此补充</span><br><span class="line">    public function sampleMethod2() &#123;</span><br><span class="line">        echo &#39;Adapter sampleMethod2 &lt;br &#x2F;&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Client &#123;</span><br><span class="line">   &#x2F;&#x2F;Main program.</span><br><span class="line">    public static function main() &#123;</span><br><span class="line">        $adaptee &#x3D; new Adaptee();</span><br><span class="line">        $adapter &#x3D; new Adapter($adaptee);</span><br><span class="line">        $adapter-&gt;sampleMethod1();</span><br><span class="line">        $adapter-&gt;sampleMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="桥接模式："><a href="#桥接模式：" class="headerlink" title="桥接模式："></a>桥接模式：</h5><p>将抽象与实现解耦，使得两者可以独立的变化<br>在程序世界中，其实就是组合/聚合的代名词。为什么这么说呢？熟悉面向对象的我们都直到继承的好处,子类可以共享父类的很多的属性，功能。但是继承也会带来一个问题,那就是严重的耦合性。父类的修改多少都会对子类产生影响，甚至一个方法或属性的修改都有可能让所有子类都去修改一遍，这样就违背了开放封装原则，而桥接就是为了解决这个问题，它强调的是用组合/聚合的方式来共享一些能用的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">abstract Class Foods&#123;</span><br><span class="line"> public $cai;</span><br><span class="line"> abstract function makef();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;米饭</span><br><span class="line">Class Rice extends Foods&#123;</span><br><span class="line"> function MakeFood()&#123;</span><br><span class="line">  $this-&gt;cai-&gt;MakeCai();</span><br><span class="line">  echo &quot;浇饭&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Cai&#123;</span><br><span class="line"> function MakeCai();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;菜</span><br><span class="line">Class Rs implements Cai&#123;</span><br><span class="line"> function MakeCai()&#123;</span><br><span class="line">   echo &quot;肉丝&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;米饭</span><br><span class="line">$rice&#x3D;new Rice();</span><br><span class="line">&#x2F;&#x2F;菜</span><br><span class="line">$rice-&gt;cai&#x3D;new Rs();</span><br><span class="line">&#x2F;&#x2F;肉丝浇饭</span><br><span class="line">$rice-&gt;MakeFood();</span><br></pre></td></tr></table></figure><p>主食：饭</p><p>辅食：肉丝</p><p>主食，辅食两个不同的维度，各自可以继续添加种类。它们都可以独自变化互不影响，通过桥接建立一定关联，进行动态组合， 这种模式的灵活性比较高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是设计模式？&quot;&gt;&lt;a href=&quot;#什么是设计模式？&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式？&quot;&gt;&lt;/a&gt;什么是设计模式？&lt;/h4&gt;&lt;p&gt;答：经典场景的经典解决方法&lt;br&gt;模式是因为语言不够灵活，不能适应复杂的场景，而想出的方法&lt;
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript高级</title>
    <link href="http://yoursite.com/2020/10/18/javascript%E9%AB%98%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/10/18/javascript%E9%AB%98%E7%BA%A7/</id>
    <published>2020-10-18T01:18:27.000Z</published>
    <updated>2020-10-18T14:06:04.481Z</updated>
    
    <content type="html"><![CDATA[<h4 id="javascript高级"><a href="#javascript高级" class="headerlink" title="javascript高级"></a>javascript高级</h4><h5 id="绑定多个事件"><a href="#绑定多个事件" class="headerlink" title="绑定多个事件"></a>绑定多个事件</h5><p>addEventListener(‘事件’,函数,冒泡/捕捉);</p><p><em>注意：</em></p><p><em>事件名，一律不带 on 。绑定事件函数中的 “this”  指绑定该事件的对象。执行顺序，是按绑定顺序来执行的</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 例：test1.addEventListener(&quot;click&quot;,myFunction,false);</span><br><span class="line"></span><br><span class="line">function myFunction()&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="解绑事件："><a href="#解绑事件：" class="headerlink" title="解绑事件："></a>解绑事件：</h5><p>  removeEventListener(“事件”,函数名)；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：test1.removeEventListener(&quot;click&quot;,myFunction);</span><br></pre></td></tr></table></figure><h5 id="冒泡-捕捉"><a href="#冒泡-捕捉" class="headerlink" title="冒泡/捕捉"></a>冒泡/捕捉</h5><p>默认是false是冒泡传递</p><p>嵌套div ,在每个div添加一个click事件，点击时，如果发生过程是从最外层事件传递到最里面则为捕捉事件，true</p><p>如果发生过程是从最里面事件开始传递到最外层的则为冒泡事件，false</p><h5 id="停止传播与阻止行为："><a href="#停止传播与阻止行为：" class="headerlink" title="停止传播与阻止行为："></a>停止传播与阻止行为：</h5><p>停止传播：stopPropagetion();不再继续执行了，到此为止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test1.addEventListener(&quot;click&quot;,function(ev)&#123;</span><br><span class="line">ev.stopPropagetion();</span><br><span class="line">&#125;,true);</span><br></pre></td></tr></table></figure><p>阻止行为：preventDefault();阻止一个链接的点击效果</p><p>点击链接会跳转，但有时会阻止跳转。比如空表单应该阻止跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test1.addEventListener(&quot;submit&quot;,function(ev)&#123;</span><br><span class="line"> test1.preventDefault();</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><h5 id="变量作用域："><a href="#变量作用域：" class="headerlink" title="变量作用域："></a>变量作用域：</h5><p>首先在函数内查找，找不到往上层查找，直到查到window上</p><p>var的作用：var 是声明变量，var是在函数运行的上下文中，声明一个变量。如果不加var,则是一个赋值操作，是给window增加一个属性。</p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>在js里函数执行，先进行词法分析</p><p>词法分析，分析3样内容</p><ol><li>先分析参数</li><li>再分析变量声明</li><li>分析函数声明</li></ol><p>一个函数能使用的局部变量，就是从上面的3步分析而来的</p><p>具体步骤：</p><ol><li><p>函数运行前的一瞬间，生成Active Object(活动对象),下称AO</p></li><li><p>函数声明的参数，形成AO的属性，值为实参的值，为传实参则为undefined</p></li><li><p>分析变量声明，如 var age</p><p>如果AO上还没有age属性，则添加AO属性，值为undefined</p><p>如果AO上已经有age属性，则不做任何影响</p></li><li><p>分析函数声明，如function foo(){}</p><p>则把函数赋给AO.foo属性</p><p><em>注：如果此前 foo 属性已存在，则被无情的覆盖了</em></p></li></ol><h5 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h5><p>函数运行期内，关键的三个对象</p><p>AO：本函数AO上没有某属性，则继续去外层函数的AO上找，直到全局对象。叫做 作用域链</p><p>arguments：每个函数有自己的arguments ,但不向外层接着找arguments的相关属性，即 不形成链</p><p>this：沿原型查找，形成原型链</p><p>arguments是什么？</p><p>是一个对象，是一个长得很像数组的对象，内容是函数调用时的实参列表</p><p>arguments 代表收到的所有实参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sum()&#123;</span><br><span class="line"> console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">sum(1,2);</span><br><span class="line">sum(1,2,3);</span><br></pre></td></tr></table></figure><p><strong>callee属性（arguments.callee) 代表正在运行的函数自身。</strong></p><h5 id="this是谁？"><a href="#this是谁？" class="headerlink" title="this是谁？"></a>this是谁？</h5><p>js中this灵活多变，极易出错</p><p>可以按照函数的4种调用方式分别讨论：</p><ol><li><p>作为普通函数来调用时，this的值指向—&gt;window</p><p>准确的说，this为null，但被解释成window</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：function t()&#123;</span><br><span class="line">  this.age&#x3D;23;</span><br><span class="line">&#125;</span><br><span class="line">t();</span><br><span class="line">注意：在es5及以后，当this为null时，抛出异常</span><br></pre></td></tr></table></figure></li><li><p>作为对象的方法来调用</p><p>作为方法调用时，this指向其调用那一瞬间的调用者，即调用对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例：function intro()&#123;</span><br><span class="line">  alert(&quot;my name is &quot;+this.name);</span><br><span class="line">&#125;</span><br><span class="line">var dog&#x3D;&#123;&quot;name&quot;:&quot;孙二&quot;&#125;;</span><br><span class="line">dog.intro&#x3D;intro;</span><br><span class="line">dog.intro();&#x2F;&#x2F;孙二</span><br></pre></td></tr></table></figure></li><li><p>作为构造函数调用时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function cat(name,color)&#123;</span><br><span class="line">this.name&#x3D;name;</span><br><span class="line">this.color&#x3D;color;</span><br><span class="line">&#125;</span><br><span class="line">var cat&#x3D;new cat();</span><br><span class="line">new的瞬间，得到一个空对象，方法中的this指向该对象</span><br></pre></td></tr></table></figure></li><li><p>函数通过call，apply调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var t1&#x3D;document.getElementById(&quot;t1&quot;);</span><br><span class="line">var t2&#x3D;document.getElementById(&quot;t2&quot;);</span><br><span class="line">function t()&#123;</span><br><span class="line"> this.style.background&#x3D;&quot;gray&quot;;</span><br><span class="line">&#125;</span><br><span class="line">t.call(t1);</span><br><span class="line">t.call(t2);</span><br><span class="line">函数名.call(对象,参数1,参数2....);</span><br><span class="line">1.把函数的this，指向对象</span><br><span class="line">2.运行函数，传参为参数1，参数2....</span><br><span class="line">函数名.apply(对象,[参数1,参数2]);</span><br></pre></td></tr></table></figure></li></ol><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>能够读取其他函数内部变量的函数。可以理解为定义一个函数内部的函数，内部函数持有外部函数变量的引用</p><p>用途：读取函数内部的变量。让这些变量的值始终保持在内存中，不会在函数被调用后被自动清除。方便调用上下文的局部变量，利于代码封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：function f1()&#123;</span><br><span class="line">  var n&#x3D;123;</span><br><span class="line">   fuction f2()&#123;&#x2F;&#x2F;f2是一个闭包</span><br><span class="line">    alert(n);</span><br><span class="line">   &#125;</span><br><span class="line">   return f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><p>prototype：原型</p><p>所有对象的原型都是object对象，object原型是null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function cat()&#123;</span><br><span class="line">  this.climb&#x3D;function()&#123;</span><br><span class="line">   alert(&quot;爬树&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function tigger()&#123;</span><br><span class="line">  this.hunt&#x3D;function()&#123;</span><br><span class="line">   alert(&quot;打猎&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">将tigger的原型指向cat，则tigger对象也有了cat的属性</span><br><span class="line">tigger.prototype&#x3D;new cat();</span><br><span class="line">var tig&#x3D; new tigger();</span><br><span class="line">tig.climb();</span><br></pre></td></tr></table></figure><h5 id="原型冒充："><a href="#原型冒充：" class="headerlink" title="原型冒充："></a>原型冒充：</h5><p> 不使用 prototype</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function good()&#123;</span><br><span class="line"> this.iq&#x3D;120;</span><br><span class="line"> this.study&#x3D;function()&#123;</span><br><span class="line">  console.log(&quot;高效学习&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">function bad()&#123;</span><br><span class="line">  &#x2F;&#x2F;将good函数里的this指向bad</span><br><span class="line"> good.call(this);</span><br><span class="line"> this.paly&#x3D;function()&#123;</span><br><span class="line">  console.log(&quot;玩游戏&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">var good&#x3D;new good();</span><br><span class="line">var bad&#x3D;new bad();</span><br><span class="line">&#x2F;&#x2F;bad函数也有了study属性</span><br><span class="line">bad.study();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;javascript高级&quot;&gt;&lt;a href=&quot;#javascript高级&quot; class=&quot;headerlink&quot; title=&quot;javascript高级&quot;&gt;&lt;/a&gt;javascript高级&lt;/h4&gt;&lt;h5 id=&quot;绑定多个事件&quot;&gt;&lt;a href=&quot;#绑定多个事件&quot;
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>jquery</title>
    <link href="http://yoursite.com/2020/09/19/jquery/"/>
    <id>http://yoursite.com/2020/09/19/jquery/</id>
    <published>2020-09-19T15:51:13.000Z</published>
    <updated>2020-10-22T15:34:57.120Z</updated>
    
    <content type="html"><![CDATA[<h4 id="jQuery是什么？"><a href="#jQuery是什么？" class="headerlink" title="jQuery是什么？"></a>jQuery是什么？</h4><p>是封装了常用js操作函数的一个库文件</p><p>jQuery=javascript+Query 即 强大的DOM节点查询</p><p>下载</p><p>从官方网站下载时，jquery的文件名格式如下：</p><p>jquery-1.x.x-min.js 或 jquery-1.x.x.js</p><p>官方网站：<code>http://jquery.com</code></p><p>官方手册：<code>http://api.jquery.com</code></p><h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p><strong>基本选择器</strong></p><p>选择器：id   <code>$(&#39;#test1&#39;).css(&#39;background&#39;,&#39;gray&#39;);</code></p><p>​              标签<code>$(&#39;p&#39;).css(&#39;background&#39;,&#39;gray&#39;);</code></p><p>​               类<code>$(&#39;.test1&#39;).css(&#39;background&#39;,&#39;gray&#39;);</code></p><p>​              群组<code>$(&#39;#test1&#39;,&#39;.test1&#39;,&#39;p&#39;);</code></p><p>层次选择器：</p><p>​             <code>$(&#39;#test p&#39;)</code>  空格代表祖先和后代的关系</p><p>​            <code>$(&#39;#test &gt; p&#39;)</code>父子关系</p><p>​            <code>$(&#39;#test +p&#39;)</code>下一个弟弟，挨着的元素 </p><p>​          <code>$(&#39;#test ~ p&#39;)</code>所有弟弟p标签</p><p>属性选择器：</p><p>​          <code>$(&quot;input[name=&#39;email&#39;]&quot;).css(&#39;background&#39;,&#39;gray&#39;);</code> </p><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>如果选择器选出的结果仍不够细，可以用过滤器，进一步筛选， 过滤器一般写在”选择器”之后，如”选择器:过滤器”;</p><p><strong>基础过滤器</strong></p><p>   是根据对象的索引值来查找</p><pre><code>$(&apos;li:first&apos;).css(&apos;background&apos;,&apos;red&apos;); //  找第 1 个$(&apos;li:odd&apos;).css(&apos;background&apos;,&apos;blue&apos;); //  找第奇数个 , 从 0 计数$(&apos;li:eq(2)&apos;).css(&apos;background&apos; , &apos;purple&apos;); //  找第 2 个 , 从 0 计数</code></pre><p><strong>内容过滤器</strong></p><p>​        $(‘tr:contains(字符)’) 内容过滤<br>​         $(‘div:has(h1)’) 含有h1标签<br>​         $(‘a[href]’) 找含有href属性的a标签   </p><p><strong>操作属性</strong></p><pre><code>普通属性$(&apos;img&apos;).attr(&apos;src&apos;,&apos;on.jpg&apos;); css属性$(&apos;p&apos;).css(&quot;background&quot;,&quot;red&quot;);布尔属性：$(&apos;input:checkbox&apos;).prop(&apos;checked&apos;,true);</code></pre><p><strong>节点操作</strong></p><pre><code> 删除DOM节点$(&apos;li:last&apos;).remove(); 清空内容 $(&apos;li:last&apos;).empty();  增加节点$(&apos;ul&apos;).after($(&apos;&lt;ol&gt;&lt;li&gt;哈哈&lt;/li&gt;&lt;/ol&gt;&apos;));$(&apos;ol&apos;).append($(&apos;ul li:last&apos;));  节点包裹$(&apos;input:text&apos;).wrap(&apos;&lt;p&gt;&lt;/p&gt;&apos;);//input标签分别包裹在&lt;p&gt;标签里$(&apos;input:text&apos;).wrapAll(&apos;&lt;p&gt;&lt;/p&gt;&apos;);// 所有inpuy标签包裹在一个&lt;p&gt;标签里$(&apos;li&apos;).wrapInner(&apos;&lt;b&gt;&lt;/b&gt;&apos;);//包裹文本不包括节点</code></pre><h5 id="jquery与DOM对象的关系和转换"><a href="#jquery与DOM对象的关系和转换" class="headerlink" title="jquery与DOM对象的关系和转换"></a>jquery与DOM对象的关系和转换</h5><p>$()返回的是什么？是jquery对象不是dom对象。dom对象装在了jquery对象里索引分别是0，1，2….<br>       <em>jquery对象转为DOM对象</em><br>            var li=$(‘li’)[0];//得到第一个li<br>    <em>DOM对象转为jquery对象</em><br>        var li=document.getElementsByTagName(‘li’)[3];<br>        $(li).css(‘background’,’gray’);</p><h5 id="jquery对象遍历"><a href="#jquery对象遍历" class="headerlink" title="jquery对象遍历"></a>jquery对象遍历</h5><pre><code>   jquery对象.each(function(){    //里面的this指的是dom对象});    </code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>原生事件和jquery事件除了语法上稍显区别，最重要的是绑定次数：</p><p>原生多次绑定事件会被最后一次覆盖前面的事件。而jquery绑定事件都会执行。</p><h5 id="独特的ready事件"><a href="#独特的ready事件" class="headerlink" title="独特的ready事件"></a>独特的ready事件</h5><p>相当于原生的onload属性，但ready不同。onload是在加载完毕后执行，ready是一开始就先执行<br>    $(document).ready(function(){});简写：$(function(){})</p><h5 id="jquery特有的绑定函数："><a href="#jquery特有的绑定函数：" class="headerlink" title="jquery特有的绑定函数："></a>jquery特有的绑定函数：</h5><p>​    bing() unbing()<br>​      //绑定click事件<br>​    $(‘#test’).bind(‘click’,function(){});<br>​      //取消绑定click事件<br>​    $(‘#test’).unbind(‘click’);<br>​      //绑定一次事件，执行一次<br>​    $(‘#test’).one(‘click’,function(){});<br>​      //动态绑定，为后来增加的节点也绑定<br>​    $(‘.test’).live(‘click’,function(){});</p><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>​    给父元素绑定事件，子元素都能执行<br>​    使用 on()函数<br>​    <code>$(ul).on(&#39;click&#39;,&#39;li&#39;,function(){});</code></p><h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><p> <code>$(&#39;div&#39;).click(function(ev){    alert(ev.type + &#39;:&#39; +ev.which);    });</code></p><h5 id="Ajax之GET请求："><a href="#Ajax之GET请求：" class="headerlink" title="Ajax之GET请求："></a>Ajax之GET请求：</h5><p>​      //get请求  res是返回的值<br>​    $.get(url,function(res){ }  ;</p><h5 id="Ajax之POST请求"><a href="#Ajax之POST请求" class="headerlink" title="Ajax之POST请求"></a>Ajax之POST请求</h5><p>​        //data可以是字符串，也可以是对象方式<br>​       <code>//data=&#39;username=lisi&amp;email=lisi@qq.com&#39;​       // data={&#39;username&#39;:&#39;lisi&#39;,&#39;email&#39;:lisi@qq.com}​     $.post(url,data,function(res){​     }</code></p><h5 id="json格式的返回值"><a href="#json格式的返回值" class="headerlink" title="json格式的返回值"></a>json格式的返回值</h5><pre><code>   //第三个参数声明返回的格式   //有键值对的返回对象格式的json，没有键值对的返回数组格式的json$.get(url,function(res){},&apos;json&apos;);</code></pre><h5 id="ajax事件监听函数"><a href="#ajax事件监听函数" class="headerlink" title="ajax事件监听函数"></a>ajax事件监听函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;$.ajax()&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot; 提交 &quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(&#39;form&#39;).submit(function()&#123;</span><br><span class="line">    var param &#x3D; &#123;</span><br><span class="line">    url : &#39;33.php&#39;,</span><br><span class="line">    type : &#39;post&#39;,</span><br><span class="line">    data : &#123;u:&#39;lisi&#39;,pass:&#39;11111&#39;&#125;,</span><br><span class="line">    success:function(res)&#123;</span><br><span class="line">    alert(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    $.ajax(&#39;2.php&#39;,param);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;ajax开始了 监听全局ajax</span><br><span class="line">    &#x2F;&#x2F; ajaxStart() ajaxSuccess() 这几个函数 , 只能绑定 $(document) 节点上 .(from jQuery1.8+)</span><br><span class="line">    $(document).ajaxStart(function()&#123;</span><br><span class="line">    $(&#39;input&#39;).val(&#39; 提交中 &#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;jQuery是什么？&quot;&gt;&lt;a href=&quot;#jQuery是什么？&quot; class=&quot;headerlink&quot; title=&quot;jQuery是什么？&quot;&gt;&lt;/a&gt;jQuery是什么？&lt;/h4&gt;&lt;p&gt;是封装了常用js操作函数的一个库文件&lt;/p&gt;
&lt;p&gt;jQuery=javas
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ajax</title>
    <link href="http://yoursite.com/2020/09/18/ajax/"/>
    <id>http://yoursite.com/2020/09/18/ajax/</id>
    <published>2020-09-17T17:13:00.000Z</published>
    <updated>2020-10-22T15:35:29.883Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p><strong>原理</strong></p><p>  访问网站，离不开HTTP协议，离不开请求与响应<br>  客户端–请求–&gt;server<br>  客户端&lt;–响应–server<br>  浏览器中，提供一个js对象–XMLHttpRequest<br>  它帮我们发送HTTP请求，并接受Server的响应<br>  这意味着，我们的浏览器不提交，通过js也可以请求服务器<br>  Ajax其实就是通过XHR对象，执行HTTP请求，<br>  所以，学习的关键是–弄清XHR对象的属性和方法</p><h5 id="XHR对象"><a href="#XHR对象" class="headerlink" title="XHR对象"></a>XHR对象</h5><p>创建XHR对象？<br>  var xhr=new XMLHttpRequest();<br>  对象的属性和方法<br>  方法：<br>  open(‘get/post’,url,true/false);//打开网址<br>  send(null);//有参数则k=v&amp;k2=v2这种形式传过去，无参数则填null<br>  属性：<br>   readyState;//代表请求的状态，不断变化，0变化到4的时候，请求全部结束<br>   responseText;//响应的内容<br>   status;//响应状态码200，403，404<br>   statusText;//状态文字，ok<br>   事件：<br>    onreadystatechange=function(){}//当readyState变化时，会触发此事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例：ajax发送get:</span><br><span class="line"></span><br><span class="line">var xhr&#x3D;new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange&#x3D;function()&#123;</span><br><span class="line">if(xhr.readyState&#x3D;&#x3D;4)&#123;</span><br><span class="line">alert(&#39;响应内容为&#39;+this.responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&#39;GET&#39;,url,true);</span><br><span class="line">xhr.send(null);</span><br><span class="line"></span><br><span class="line">ajax发送post:</span><br><span class="line"></span><br><span class="line">POST 的参数以 k1&#x3D;v1&amp;k2&#x3D;v2&amp;k3&#x3D;v3 的形式拼接 , 并用 send() 发送</span><br><span class="line">     var xhr&#x3D;new XMLHttpRequest();</span><br><span class="line"> xhr.onreadystatechange&#x3D;function()&#123;</span><br><span class="line">if(xhr.readyState&#x3D;&#x3D;4)&#123;</span><br><span class="line">alert(&#39;响应内容为&#39;+this.responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">     xhr.open(&#39;POST&#39;,url,true);</span><br><span class="line">  &#x2F;&#x2F;头信息</span><br><span class="line"> xhr.setRequestHeader(&#39;Content-Type&#39; , &#39;application&#x2F;x-www-form-urlencoded&#39;);</span><br><span class="line"> xhr.send(&#39;k1&#x3D;v1&amp;k2&#x3D;v2&#39;);</span><br></pre></td></tr></table></figure><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>返回值只有2种，text,XML两种<br>    但text的内容可以是一段HTML，也可以是json结构的字符串<br>    返回json格式：多条或多种数据，需要清晰传递时<br>      json格式的字符串，要eval一下，转为js的对象<br>      //响应的内容为数组格式<br>      eval(‘(‘+this.responseText+’)’);<br>    返回HTML代码：需要更新大面积HTML内容时<br>    在php页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> ?&gt;</span><br><span class="line"> &lt;table&gt;</span><br><span class="line">   &lt;tr&gt;&lt;&#x2F;tr&gt;</span><br><span class="line"> &lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p> 返回xml：已经大部分被 json取代</p><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><p>var xhr=new XMLHttpRequest();<br>     xhr.open(‘get’,url,true);<br>     open方法中第三个参数是表示同步异步<br>     true是异步，不影响继续往下执行<br>     false是同步，返回结果后才往下继续执行，阻塞后面代码的执行</p><h5 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h5><p>ajax默认情况下只能请求同域名下的内容<br>    ajax能不能跨域，取决于对方网站是否允许</p><pre><code>参考文档：https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS对方网站设置如下则可以被跨域：&lt;?php header(Access-Control-Allow-Origin: *); echo &apos;可以被跨域&apos;;?&gt;ajax提交到php页面,php采集要访问的地址，然后再返回去    php页面:            $xml=$_file_get_contents(url);            echo $xml;</code></pre><p><strong>另一种跨域解决方法：jsonp</strong></p><p>jsonp严格来说，不属于ajax技术因为根本没使用xmlhttpRequest();<br>    为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，<br>    该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回<br>    数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意<br>    定制自己的函数来自动处理返回数据了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">例：&lt;body&gt;</span><br><span class="line">&lt;h1&gt;360 搜索推荐 &lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;word&quot; onkeyup&#x3D;&quot;test1();&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;ul&gt;&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function test1() &#123;</span><br><span class="line">var inp &#x3D; document.getElementsByTagName(&#39;input&#39;)[0];</span><br><span class="line">var url &#x3D; &#39;http:&#x2F;&#x2F;sug.so.360.cn&#x2F;suggest?callback&#x3D;suggest_so&amp;encodein&#x3D;utf-8&amp;encodeout&#x3D;utf-8&amp;format&#x3D;json&amp;fields&#x3D;word,obdata&amp;word&#x3D;&#39;+inp.value;</span><br><span class="line">&#x2F;&#x2F;alert(url);</span><br><span class="line">var sc &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">sc.src &#x3D; url;</span><br><span class="line">document.getElementsByTagName(&#39;head&#39;)[0].appendChild(sc);</span><br><span class="line">&#125;</span><br><span class="line">function suggest_so(obj) &#123;</span><br><span class="line">&#x2F;&#x2F;alert(obj);</span><br><span class="line">var html &#x3D; &#39;&#39;;</span><br><span class="line">for(var i &#x3D;0; i&lt; obj.result.length; i+&#x3D;1) &#123;</span><br><span class="line">html &#x3D; html + &#39;&lt;li&gt;&#39; + obj.result[i].word + &#39;&lt;&#x2F;li&gt;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementsByTagName(&#39;ul&#39;)[0].innerHTML &#x3D; html;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="ajax文件上传"><a href="#ajax文件上传" class="headerlink" title="ajax文件上传"></a>ajax文件上传</h4><p>ajax上传文件，则意味着js的xmlhttprequest对象，可以获取文件的信息<br>  处于安全考虑，js不能获取磁盘上的文件<br>  因此ajax上传文件做不到<br>  ajax上传其实是用的是iframe伪装，不是真的ajax上传<br>  HTML5后，浏览器新增了formData对象，且xhr对象也新增了一些功能<br>  可以让我们完成ajax上传，且有进度条看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">&lt;p&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;pic&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot; 走 &quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;width:500px;height:10px;border:1px solid blue&quot;&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;prog&quot; style&#x3D;&quot;height:100%;width:0%;background:blue;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementsByTagName(&#39;form&#39;)[0].onsubmit &#x3D; function() &#123;</span><br><span class="line">&#x2F;&#x2F;formData会把表单的数据(包括文件)，整体打包</span><br><span class="line">var fd &#x3D; new FormData(this);</span><br><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">console.log(xhr);</span><br><span class="line">xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">if(this.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">alert(this.responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;进度条</span><br><span class="line">xhr.upload.onprogress &#x3D; function (ev) &#123;</span><br><span class="line">&#x2F;&#x2F;console.log(ev);</span><br><span class="line">if(ev.lengthComputable&#x3D;&#x3D;true) &#123;</span><br><span class="line">var per &#x3D; parseInt(100 * ev.loaded &#x2F; ev.total);</span><br><span class="line">document.getElementById(&#39;prog&#39;).style.width &#x3D; (per + &#39;%&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ajax 有 &quot; 同源策略 &quot;, 即只能请求相同域名下的 URL</span><br><span class="line">xhr.open(&#39;post&#39; ,&#39;11.php&#39; , true);</span><br><span class="line">xhr.send(fd);</span><br><span class="line">return false;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="小心url中文参数："><a href="#小心url中文参数：" class="headerlink" title="小心url中文参数："></a>小心url中文参数：</h5><h5 id="页面表单上填写中文浏览器会自动编码，但url地址栏get方式中文参数一般不会编"><a href="#页面表单上填写中文浏览器会自动编码，但url地址栏get方式中文参数一般不会编" class="headerlink" title="页面表单上填写中文浏览器会自动编码，但url地址栏get方式中文参数一般不会编"></a>页面表单上填写中文浏览器会自动编码，但url地址栏get方式中文参数一般不会编</h5><p>   使用encodeURI(‘中文’)来编码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Ajax&quot;&gt;&lt;a href=&quot;#Ajax&quot; class=&quot;headerlink&quot; title=&quot;Ajax&quot;&gt;&lt;/a&gt;Ajax&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  访问网站，离不开HTTP协议，离不开请求与响应&lt;br&gt;  客户端–
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript</title>
    <link href="http://yoursite.com/2020/09/17/javascript/"/>
    <id>http://yoursite.com/2020/09/17/javascript/</id>
    <published>2020-09-17T14:38:49.000Z</published>
    <updated>2020-10-22T15:36:08.136Z</updated>
    
    <content type="html"><![CDATA[<h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><p>学习javascript要分清：</p><ol><li>js语言本身的语法</li><li>DOM对象(把body,div,p等节点树看成一个对象)</li><li>BOM对象(把浏览器的地址栏，历史纪录，DOM等装在一个对象)</li></ol><p>浏览器是宿主，但js的宿主不限于浏览器，也可能是服务器端如比较流行的服务器端js框架：node.js</p><h5 id="引入js："><a href="#引入js：" class="headerlink" title="引入js："></a>引入js：</h5><ul><li><p>页内script代码</p><p><code>&lt;script&gt;    &lt;/script&gt;</code></p></li><li><p>外部js文件(外部js文件里面直接写js代码，不用在开头和结尾加标签）</p><p><code>&lt;script src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt;</code></p><p><strong>script标签写在页面的哪个位置 ?</strong></p><p>页面head标签和body都不可以，但一般写在body标签后面  </p></li></ul><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><p>js的变量名，可以用  _ ，数字，字母，$组成，但数字不能开头</p><p>声明变量， 用 var 变量名来声明</p><p><code>var a=34; var b=45; alert(a+b);</code></p><p><em>注意：变量名区分大小写， str和 Str不是一个变量</em></p><p>​            <em>不用var 会污染全局变量</em> </p><h5 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类型：</span><br><span class="line">1.数值型       var a&#x3D;23;</span><br><span class="line">2.字符串型     var c&#x3D;&#39;hello&#39;;</span><br><span class="line">3.布尔型       var e&#x3D;true;</span><br><span class="line">4.null型       var f&#x3D;null;</span><br><span class="line">5.undefined型  var g&#x3D;undefined;</span><br></pre></td></tr></table></figure><p>null是代表对象不存在，在用DOM操作寻找DOM对象时，没找到，返回Null</p><p>如果一个基本型没定义，理解为undefined</p><p>数组：var h=[‘张’,’王’,’李’];</p><p>对象：var i={‘name’:’poly’,’age’:3};</p><h5 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">循环数组：</span><br><span class="line">     var arr &#x3D; [&#39; 赵 &#39;,&#39; 钱 &#39;,&#39; 孙 &#39;,&#39; 李 &#39;];</span><br><span class="line"> for(var i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">console.log(arr[i]);</span><br><span class="line"> &#125;</span><br><span class="line">循环对象：</span><br><span class="line"> var obj &#x3D; &#123;&#39;name&#39;:&#39;lisi&#39;,&#39;age&#39;:29,&#39;height&#39;:180&#125;;</span><br><span class="line">for(var k in obj) &#123; &#x2F;&#x2F;  循环 obj, 把键分别赋给 k,</span><br><span class="line">console.log(k);</span><br><span class="line">console.log(obj.k); &#x2F;&#x2F;  错误 k被当成属性对待了，所以变量不要用 .</span><br><span class="line">console.log(obj[k]); &#x2F;&#x2F;  正确</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><ol><li>String字符串对象</li><li>Date日期对象</li><li>Math数学对象</li><li>数组对象</li></ol><h5 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h5><p>window对象是浏览器宿主对象，与js语言无关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法：window.alert(message),window.open(URL,位置)打开窗口,window.setTimeout(表达式，毫秒)等</span><br><span class="line">windo对象的子对象：</span><br><span class="line"> 1.navigator浏览器信息对象</span><br><span class="line"> 2.location 地址栏对象</span><br><span class="line"> 3.history历史记录</span><br><span class="line"> 4.screen屏幕对象</span><br><span class="line"> 5.document HTML文档对象即HTML代码形成的对象, 操作此对象,可动态的改变页面的内容.是我们做 JS 的主战场</span><br></pre></td></tr></table></figure><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>var的本质：</p><p>var a=3；//声明a变量并赋值</p><p>b=3;//只是一个”赋值”</p><p>js作用域的特点：</p><p>首先在函数内部查找变量，找不到则到外层函数查找，逐步找到最外层即window对象并操作window对象的属性</p><h5 id="找对象"><a href="#找对象" class="headerlink" title="找对象"></a>找对象</h5><p>1.按id找<br>      document.getElementById(‘test1’);</p><p>2.按标签 哪怕只找到1个,也包装成”数组”来返回<br>      document.getElementsByTagName(‘h1’);<br>3.按照类名<br>      document.getElementByClassName(‘test2’)[0];<br>4.对于表单元素，可以按name来查询<br>      document.getElementsByName(‘username’)[0];</p><p><strong>操作对象属性</strong>：</p><p>普通属性可以通过 对象.标签属性 来访问</p><p>CSS属性通过：</p><p>对象.style.属性</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&quot; alt&#x3D;&quot;&quot; title&#x3D;&quot;&quot; style&#x3D;&quot;width:200px;height:300px;&quot;&#x2F;&gt;</span><br><span class="line">img对象</span><br><span class="line"> .src</span><br><span class="line"> .alt</span><br><span class="line"> .title</span><br><span class="line"> .style------&gt;width </span><br><span class="line">              height</span><br><span class="line">一般来说都是这样的：</span><br><span class="line">imgobj.src 对应 &lt;img src&#x3D;&quot;&quot;&gt;</span><br><span class="line">但也有例外：</span><br><span class="line">  &lt;div class&#x3D;&quot;main&quot;&gt; 是这样的 divobj.className</span><br><span class="line">如果css属性带有横线如border-top-style</span><br><span class="line">    则把横线去除并横线后的字母大写</span><br><span class="line">     obj.style.borderTopStyle</span><br></pre></td></tr></table></figure><p>obj.style只能取得内联style的值，对于<code>&lt;style&gt;&lt;/style&gt;</code>中的css属性值，则无能为力</p><p>我们可以用window.getComputedStyle(el,null)来获取</p><p>第一个参数el为目标元素，第二个参数为期望的伪元素，一般为null</p><p>注意：这个方法获取的对象是只读的，要改样式，还得靠 obj.style</p><h5 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h5><ol><li><p>找到对象</p><p> <code>var childObj=document.getElementByTagName(&#39;li&#39;)[0];</code></p></li><li><p>找到父对象parentObj   </p></li></ol><p>​       <code>var ul=childObj.parentNode;</code></p><ol start="3"><li><p>parentObj.removeChild(子对象)</p><p><code>ul.removeChild(childObj);</code></p></li></ol><p>创建对象</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;创建文本节点</span><br><span class="line">  var txt&#x3D;document.createTextNode(&#39;牛&#39;);</span><br><span class="line">   &#x2F;&#x2F;创建li</span><br><span class="line">   var li&#x3D;document.createElement(&#39;li&#39;);</span><br><span class="line">   li.appendChild(txt);</span><br><span class="line">2.找到父对象parentObj</span><br><span class="line">    var ul&#x3D;document.getElementByTagName(&#39;ul&#39;)[0];</span><br><span class="line">3.parentObj.appendChild(对象);</span><br><span class="line">  ul.appendChild(li);</span><br></pre></td></tr></table></figure><h5 id="暴力操作节点"><a href="#暴力操作节点" class="headerlink" title="暴力操作节点"></a>暴力操作节点</h5><pre><code>innerHTML:代表节点内的内容，能读能写找到父节点 var main=document.getElementById(&apos;main&apos;);将添加的内容写成字符串 var html=&quot;&lt;ul&gt;&lt;li&gt;春&lt;/li&gt;&lt;li&gt;夏&lt;/li&gt;&lt;/ul&gt;&quot;;直接赋值  main.innerHTML=html;</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>常用事件</p><p>​     onclick 元素点击时<br>​      onfocus 元素获得焦点时<br>​      onblur  元素失去焦点时<br>​      onmouseover 鼠标经过时<br>​      onsubmit   表单提交<br>​      onload     页面加载完毕时<br>​      oninput   input内容变化时触发</p><h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><p>事件发生的瞬间，发生位置,时间,鼠标按键,触发的节点等信息,被打包成1个对象<br>此对象,系统自动传递给事件函数的第一个参数<br>      对象.事件=function(ev){<br>          ev就是事件对象<br>      }<br>     例：<br>          img.onmouseover=function(ev){<br>        }</p><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>当有比较多的元素需要绑定某事件时，可以把事件绑定在他们的父元素上<br>     委托给父元素来处理</p><h4 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h4><p>json对象：</p><p> js允许通过键值对形式写对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj&#x3D;&#123;name:&#39;lisi&#39;，age&#x3D;29&#125;</span><br><span class="line">php处理json：</span><br><span class="line">$obj&#x3D;array(&#39;name&#39;&#x3D;&gt;&#39;lisi&#39;,age&#x3D;&gt;29);</span><br><span class="line">&#x2F;&#x2F;php数组编成json格式</span><br><span class="line">echo json_encode($obj);&#x2F;&#x2F;&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:29&#125;</span><br><span class="line">&#x2F;&#x2F; json 格式解码成 PHP 数组形式</span><br><span class="line">$str &#x3D; &#39;&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:29&#125;&#39;;</span><br><span class="line">print_r(json_encode($str,true)); &#x2F;&#x2F; array(&#39;name&#39;&#x3D;&gt;&#39;lisi&#39;,&#39;age&#39;&#x3D;&gt;29);</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>js中没有类，只有构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   function Dog(name,color) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.color &#x3D; color;</span><br><span class="line">this.bark &#x3D; function() &#123;</span><br><span class="line">alert(&#39;my name is &#39; + this.name + &#39;,color:&#39; + this.color );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var dog&#x3D;new Dog(&#39;xiaohei&#39;,&#39;block&#39;);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure><p>//new的过程</p><p>先造一个空对象{}<br>this指向该空对象</p><p>执行函数体：对象.name=传来的值</p><p>返回该对象</p><p><em>注意：不要直接运行构造方法，Dog(xx,xx);</em></p><p><em>this是null，会指向window，导致window多了name,color,bark这几个全局变量</em><br>    <em>在最新的js标准中，this不再理解为window而是抛出错误信息</em></p><h5 id="this是谁？"><a href="#this是谁？" class="headerlink" title="this是谁？"></a>this是谁？</h5><p>​     js中，this始终指向当前调用者对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;javascript&quot;&gt;&lt;a href=&quot;#javascript&quot; class=&quot;headerlink&quot; title=&quot;javascript&quot;&gt;&lt;/a&gt;javascript&lt;/h4&gt;&lt;p&gt;学习javascript要分清：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;js语言本身的语
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>http协议</title>
    <link href="http://yoursite.com/2020/09/09/http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/09/09/http%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-09-09T01:39:46.000Z</published>
    <updated>2020-09-10T01:35:21.426Z</updated>
    
    <content type="html"><![CDATA[<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>http：超文本传输协议，详细的规定了万维网服务器与客户端之间数据传送的通信规则</p><p>http是一个基于TCP/IP通信协议来传递数据(HTML文件，图片文件，查询结果等)。属于应用层的面向对象的协议</p><p>http协议工作于客户端-服务端架构为上，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。WEB服务器根据接收到的请求后，向客户端发送响应信息。</p><h5 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h5><p>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET,POST，HEAD。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>2、灵活：http允许传输任意类型的数据对象</p><p>3、无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</p><p>4、无状态：HTTP协议是无状态协议，无状态是指协议对于事物处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就较快。</p><p>http请求和响应都分三部分：</p><p>打开DOS窗口  建立连接  <code>telnet localhost 80</code>   然后写请求规则去请求服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">请求格式：</span><br><span class="line"></span><br><span class="line">   请求行： GET&#x2F;POST(请求方式)   &#x2F;01.php(访问路径)  HTTP&#x2F;1.1(协议规则)</span><br><span class="line"></span><br><span class="line">   请求头： host :localhost(要访问的主机)</span><br><span class="line"></span><br><span class="line">​          post提交时需添加 Content-type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">​          post提交数据的长度Content-length: 10</span><br><span class="line"></span><br><span class="line">   空行</span><br><span class="line"></span><br><span class="line">   主体信息    key&#x3D;12&amp;name&#x3D;aa(要传递的信息)&#x2F;&#x2F;如果要发送cookie则这样写Cookie:username&#x3D;lisi;age&#x3D;12;</span><br><span class="line">返回的响应格式：</span><br><span class="line">响应行       响应协议http&#x2F;1.1  状态码200  状态码响应描述ok</span><br><span class="line">响应头       server:apache&#x2F;2.2.2</span><br><span class="line"></span><br><span class="line">响应主体     主体信息</span><br></pre></td></tr></table></figure><h5 id="HTTP之状态码"><a href="#HTTP之状态码" class="headerlink" title="HTTP之状态码"></a>HTTP之状态码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx：指示信息--表示请求已接收，继续处理</span><br><span class="line">2xx：成功--表示请求已被成功接收、理解、接受</span><br><span class="line">3xx：重定向--要完成请求必须进行更进一步的操作</span><br><span class="line">4xx：客户端错误--请求有语法错误或请求无法实现</span><br><span class="line">5xx：服务器端错误--服务器未能实现合法的请求</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;协议&quot;&gt;&lt;a href=&quot;#协议&quot; class=&quot;headerlink&quot; title=&quot;协议&quot;&gt;&lt;/a&gt;协议&lt;/h4&gt;&lt;p&gt;http：超文本传输协议，详细的规定了万维网服务器与客户端之间数据传送的通信规则&lt;/p&gt;
&lt;p&gt;http是一个基于TCP/IP通信协议来传递
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>正则</title>
    <link href="http://yoursite.com/2020/09/09/%E6%AD%A3%E5%88%99/"/>
    <id>http://yoursite.com/2020/09/09/%E6%AD%A3%E5%88%99/</id>
    <published>2020-09-09T01:11:02.000Z</published>
    <updated>2020-09-09T01:35:42.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>正则表达式不是哪一门编程语言，是一个独立的知识，比C语言更古老，正则是字符串规律的描述字符串。</p><h4 id="正则三段式"><a href="#正则三段式" class="headerlink" title="正则三段式"></a>正则三段式</h4><h5 id="1、从哪里找？"><a href="#1、从哪里找？" class="headerlink" title="1、从哪里找？"></a>1、从哪里找？</h5><p>位置符，从字符串什么地方开始查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^ 匹配字符串的开始</span><br><span class="line">$ 匹配字符串的结尾</span><br><span class="line">\b匹配单词的开始和结尾</span><br><span class="line">\B匹配单词的非边界</span><br></pre></td></tr></table></figure><h5 id="2、找谁？"><a href="#2、找谁？" class="headerlink" title="2、找谁？"></a>2、找谁？</h5><p>   /匹配字符/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">字符集合[ace],[123456789]</span><br><span class="line">字符补集[^qxz]不再qxz范围内</span><br><span class="line">字符范围[a-z0-9]</span><br><span class="line">.   代表任意字符，不含换行</span><br><span class="line">\w  [a-zA-Z0-9_]</span><br><span class="line">\W  \w的补集</span><br><span class="line">\s  空白符，包括\n\r\t\v等</span><br><span class="line">\S  非空白符</span><br><span class="line">\d  [0-9]</span><br><span class="line">\D  非数字</span><br></pre></td></tr></table></figure><h5 id="3、找几个"><a href="#3、找几个" class="headerlink" title="3、找几个"></a>3、找几个</h5><p>限定符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[a-z]&#123;5&#125; 表示找出5个a-z范围内的字母</span><br><span class="line">&#123;1，&#125;  表示至少一个    用+表示</span><br><span class="line">&#123;0，1&#125; 表示最多一个    用？表示</span><br><span class="line">&#123;0，&#125;  表示零次或多次  用*表示</span><br><span class="line">&#123;n,m&#125; 表示匹配n-m次</span><br></pre></td></tr></table></figure><h5 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h5><p>贪婪：查找到最后一个匹配的字母则结束，中间有符合的也不会停下来，而是继续查找到最后一个匹配</p><p>非贪婪：查找到一个则匹配出来，一旦匹配到就停止查找</p><p>在限定符后加？如：/g.+?d/ 表示非贪婪模式</p><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>引用前面定义好的规则：将之前定义好的规则用()包括起来，用\1或$1引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$str&#x3D;&#39;txt php java o2o javascript android object-c ruby&#39;;</span><br><span class="line">$patt&#x3D;&#39;&#x2F;\b([a-z])\w+\1\b&#x2F;&#39;;</span><br><span class="line">preg_match_all($patt,$str,$ma);</span><br><span class="line">print_r($ma);</span><br><span class="line">([a-z])就是被引用的规则 \1表示应用规则的标识</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;正则&quot;&gt;&lt;a href=&quot;#正则&quot; class=&quot;headerlink&quot; title=&quot;正则&quot;&gt;&lt;/a&gt;正则&lt;/h4&gt;&lt;p&gt;正则表达式不是哪一门编程语言，是一个独立的知识，比C语言更古老，正则是字符串规律的描述字符串。&lt;/p&gt;
&lt;h4 id=&quot;正则三段式&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="http://yoursite.com/2020/09/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2020/09/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-09-08T00:40:26.000Z</published>
    <updated>2020-09-08T01:55:48.059Z</updated>
    
    <content type="html"><![CDATA[<h4 id="何为面向对象？"><a href="#何为面向对象？" class="headerlink" title="何为面向对象？"></a>何为面向对象？</h4><p>在面向对象的程序设计（oop)中，对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。万物皆对象</p><p>对象的主要三个特性：</p><ol><li>对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为</li><li>对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型</li><li>对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同</li></ol><h5 id="怎学习面向对象？"><a href="#怎学习面向对象？" class="headerlink" title="怎学习面向对象？"></a>怎学习面向对象？</h5><ul><li>类声明语法，声明一个student类，有score属性和study方法</li><li>权限封装，知道public，protected，private各自的可见范围</li><li>继承，写A类，再写B类 继承自A类，且要重写A类中的某个方法</li><li>静态属性和静态方法，知道static静态方法需要用类名::方法名()调用</li><li>魔术方法，了解常用魔术方法分别在什么时间调用</li><li>写一个抽象类，并用2个子类，分别继承实现，分析2个子类有什么共同特点</li><li>写一个接口，并用2个子类分别继承，分析2个类有什么共同点</li></ul><h5 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h5><p>定义了一件事物的抽象特点，类的定义包含了数据的形式以及对数据的操作</p><p>就是大量的，同类事物共同特点的抽象描述。</p><p>而对象，是以类做模板，形成的一个具体实例</p><h5 id="类的三大特征：封装，继承，多态"><a href="#类的三大特征：封装，继承，多态" class="headerlink" title="类的三大特征：封装，继承，多态"></a>类的三大特征：封装，继承，多态</h5><p>封装：封装对象内部的某些属性和方法，为外部不可见，开放某些接口，来操作受保护的内部方法或属性</p><p>​           protected 类中protected属性，在对象实例化之后，在类外部调用该属性是不允许的，类内部可以控制</p><p>继承：某个类可以继承另一个类的属性和方法</p><p>​           class 子类  extends 父类</p><p>final：最终的，使用final修饰的属性和方法，可以被继承但不能重写</p><p>​           final修饰类，则该类不能被继承</p><p>权限：</p><p>​       public                公有            可以被外部，子类，本类中调用</p><p>​       proteceted     被保护          外部不可调用，子类，本类中可以调用</p><p>​       private             私有            外部，子类都不可调用，本类可以调用</p><h5 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h5><p>​        类的静态属性和普通对象的属性不一样，静态属性属于类所有，一个类在页面中可以声明一次，因此一个类的静态属性在内存中中有一份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：static  public  $legs;</span><br><span class="line">调用：类名：：$legs;</span><br></pre></td></tr></table></figure><p>类常量：避免常量名重复，不能使用。</p><p>​               类常量只在类内部起作用的常量</p><p><code>define(&#39;PI&#39;,3.1415926);定义常量</code></p><p><code>const PI=3.1415926;类常量</code></p><p>调用：类名::类常量</p><h5 id="this是谁？"><a href="#this是谁？" class="headerlink" title="this是谁？"></a>this是谁？</h5><p>$this是一个虚拟变量，专门指 当前调用的对象</p><h5 id="self-和parent"><a href="#self-和parent" class="headerlink" title="self 和parent"></a>self 和parent</h5><p>$this 代表 本对象</p><p>self  代表 本类</p><p>parent 代表父类</p><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>单例模式用到的知识就是静态属性和方法</p><ul><li>不允许类new操作  给构造方法添加权限 protected</li><li>在类内部开放一个接口，来实例化对象</li><li>在接口里加判断 new对象，返回静态变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class single&#123;</span><br><span class="line">&#x2F;&#x2F;不允许类new操作</span><br><span class="line">protected function __construct()&#123;</span><br><span class="line">&#125;</span><br><span class="line">    &#x2F;&#x2F;定义一个静态变量用来存储对象</span><br><span class="line">    public static $ins&#x3D;null;</span><br><span class="line">    &#x2F;&#x2F;开放一个接口</span><br><span class="line">    public static function getins()&#123;</span><br><span class="line">     &#x2F;&#x2F;加判断</span><br><span class="line">     if(self::$ins)&#123;</span><br><span class="line">       return self::$ins;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">        self::$ins&#x3D;new self();</span><br><span class="line">        return self::$ins;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="魔术方法："><a href="#魔术方法：" class="headerlink" title="魔术方法："></a>魔术方法：</h5><p>​    某种场景下，能够自动调用的方法<br>​    如：_construct、_destruct、_set、_get、_isset、_unset、_call<br>​    _construct(): 构造方法,new 实例时,自动调用<br>​    _destruct(): 析构方法,对象销毁时自动调用<br>​    _get(属性名): 当读取对象的一个不可见属性时,自动调用,并返回值不可见： 未定义或无权访问时<br>​    __set(属性名,属性值): 当对一个不可见的属性赋值时,自动调用<br>​    _isset(属性名): 当用isset,或empty判断一个不可见属性时,自动调用<br>​    _unset(属性名): 当unset一个不可见属性时,自动调用<br>​    _call()：当调用不存在的方法时，自动调用</p><h5 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h5><p>类前要加abstract ，则为抽象类</p><p>方法前也可以加abstarct ，则为抽象方法</p><p>抽象方法没有方法体</p><p>抽象类中也可以有已经实现的方法，但只要有一个抽象方法，则类就是抽象的</p><p>抽象类不能实例化</p><p>子类继承抽象类必须实现其抽象方法</p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>抽象类可以理解为“类的模板”，接口则是“方法”的模板</p><p>即，接口的粒度更小，用于描述通用的方法，</p><p>接口本身就是抽象的，方法前不用加abstract</p><p>接口里的方法，只能是public</p><p>类可以同时实现多个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface iTemplate&#123;</span><br><span class="line">    public fucntion setVariable($name);</span><br><span class="line">    &#125;</span><br><span class="line">    class Template implements iTemplate&#123;</span><br><span class="line">     public function setVariable($name)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>在需要出错的地方</p><p>抛出异常：throw  new Exception(‘string’,int);</p><p>捕捉异常：</p><pre><code>try{ 抛出异常的地方}catch(Exception $e){ //捕捉到异常 echo &apos;文件:&apos;,$e-&gt;getFile() echo &apos;行:&apos;,$e-&gt;getLine() echo &apos;错误信息:&apos;,$e-&gt;getMessage()}</code></pre><p>   什么时间用异常：不该出错的地方，却有可能出错，就用异常<br>   如：连接数据库，不应该出错，<br>   如：查询用户是否存在，可能返回true/false，此时就用return</p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>引入命名空间，声明某个空间，避免重名  </p><pre><code>例: 写2个.php 测试    文件: test1.php    namespace zixueit;    class Mysqli {    public $test = &apos;my-mysqli&apos;;    }    文件:test2.php    require(&apos;./test1.php&apos;);    print_r(new MySQLi());    print_r(new \zixue\MySQLi());    // 也可以先use,new时就不用加路径了    use \zixueit\Mysqli;    print_r(new Mysqli()); namespace的声明，必须在页面第一行 namespace声明后，其后的类，函数，都被封锁在命名空间内 require/include其他带有命名空间的页面，自身的空间，并没有受干扰 如果想明确的使用某空间下的类, 可以从根空间,逐步寻找,如\zixueit\Class(); 如果频繁用某个空间下的类,可以先use声明 自动加载函数的参数,包含 &quot;空间路径\类名&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;何为面向对象？&quot;&gt;&lt;a href=&quot;#何为面向对象？&quot; class=&quot;headerlink&quot; title=&quot;何为面向对象？&quot;&gt;&lt;/a&gt;何为面向对象？&lt;/h4&gt;&lt;p&gt;在面向对象的程序设计（oop)中，对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>session和cookie</title>
    <link href="http://yoursite.com/2020/09/07/session%E5%92%8Ccookie/"/>
    <id>http://yoursite.com/2020/09/07/session%E5%92%8Ccookie/</id>
    <published>2020-09-07T00:16:54.000Z</published>
    <updated>2020-09-08T00:34:45.768Z</updated>
    
    <content type="html"><![CDATA[<h4 id="session和cookie的产生"><a href="#session和cookie的产生" class="headerlink" title="session和cookie的产生"></a>session和cookie的产生</h4><p>无论是什么变量，在php中是无法跨越到两个页面的。那如何像会员登陆一样，在每个页面都可以获取这个变量？</p><p>于是session和cookie产生了，利用cookie和session跟浏览器配合，共同达到这样一个效果。</p><h5 id="cookie和session的区别："><a href="#cookie和session的区别：" class="headerlink" title="cookie和session的区别："></a>cookie和session的区别：</h5><ol><li>cookie数据存放在客户的浏览器上，session数据是存放在服务器上。</li><li>cookie存储类型字符串、数字。session存储类型字符串、数字、数组、对象。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session</li><li>单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie</li><li>session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie</li></ol><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>客户端请求服务器，服务器会给客户端分配一个cookie暗号，下次请求客户端会带着cookie去访问服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">浏览器——请求———&gt;服务器</span><br><span class="line"></span><br><span class="line">浏览器&lt;——分配cookie—响应—服务器</span><br><span class="line"></span><br><span class="line">浏览器——携带cookie—请求—&gt;服务器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置cookie</span><br><span class="line">在1.php中设置：</span><br><span class="line">setcookie(&#39;user&#39;,&#39;lisi&#39;);</span><br><span class="line">在2.php中获得：</span><br><span class="line">print_r($_COOKIE);</span><br></pre></td></tr></table></figure><p>在2.php中是怎么传递过去的？</p><p>php变量是无法跨页面的，我们能达到这个效果，是因为浏览器每次都会在请求头信息中，将这个变量带过来</p><p>cookie弊端：</p><ol><li>如果setcookie设置了cookie。$_COOKIE想获取cookie的值，需要在下一次请求中才可以访问到。</li><li>cookie被附加在每个http请求中，无形中增加了流量。</li><li>cookie默认是在当前目录下有效，如果是这样，大型的网站无法做到全站登陆，cookie可以往下级目录识别，往上级目录跳是没有办法的。</li></ol><p>清除cookie:</p><p><code>setcookie(key,&#39;&#39;,0);</code> </p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;开启session</span><br><span class="line">session_start();</span><br><span class="line">&#x2F;&#x2F;给session赋值</span><br><span class="line">$_SESSION[&#39;area&#39;]&#x3D;&#39;beijing&#39;;</span><br><span class="line">&#x2F;&#x2F;销毁session</span><br><span class="line">session_destroy();</span><br></pre></td></tr></table></figure><p>无论读取，销毁都要先开启session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浏览器————请求————&gt;服务器（开启空间存储session信息）</span><br><span class="line">浏览器&lt;————分配cookie———服务器（分配session_id通过cookie）</span><br><span class="line">浏览器——携带cookie————&gt;服务器（响应返回session信息)</span><br></pre></td></tr></table></figure><p>session跟cookie不同，可以往上跳，因为session有效路径是根目录</p><p>问题：如果浏览器禁用了cookie，还可不可以使用session？</p><p>答：cookie是用来传递session_id的，禁用cookie则session不能使用。</p><p>​        但服务器需要的是session_id，我们只要把session_id传过去就可以，利用地址栏传递也是可以的</p><p><code>localhost/study/6.php?PHPSESSID=kaqed4gv5o8m7ju0ibpount8ur6</code></p><p>但这种方式不建议使用，给别人发链接的时候，会暴漏了自己的session</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;session和cookie的产生&quot;&gt;&lt;a href=&quot;#session和cookie的产生&quot; class=&quot;headerlink&quot; title=&quot;session和cookie的产生&quot;&gt;&lt;/a&gt;session和cookie的产生&lt;/h4&gt;&lt;p&gt;无论是什么变量，在p
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库视图事务等</title>
    <link href="http://yoursite.com/2020/07/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE%E4%BA%8B%E5%8A%A1%E7%AD%89/"/>
    <id>http://yoursite.com/2020/07/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%86%E5%9B%BE%E4%BA%8B%E5%8A%A1%E7%AD%89/</id>
    <published>2020-07-29T09:33:52.000Z</published>
    <updated>2020-07-30T17:12:11.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="视图-view"><a href="#视图-view" class="headerlink" title="视图 view"></a>视图 view</h4><p>视图说白了就是查询后的结果集，将这个结果集保存起来，方便下次从这个结果集中查询数据。</p><ol><li><p>怎么保存结果集？建视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名字 as(select语句...);sle</span><br><span class="line">如：</span><br><span class="line">create view sgoods as select goods_id,goods_name from goods;</span><br><span class="line">select * from sgoods;</span><br><span class="line">sgoods就是select的结果集</span><br></pre></td></tr></table></figure></li><li><p>视图的概念</p><p>view 又被称为虚拟表，view是sql语句的查询结果。一个sql的查询结果，我用view存起来，下次你查这个view,就相当于这个sql发挥作用了！</p><ul><li><p>权限控制时可以用</p><p>比如，某几个列，允许用户查询，其他列不允许查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view sgoods as select goods_id,goods_name from goods;</span><br><span class="line">select * from sgoods;</span><br><span class="line">任你怎么查询sgoods表，也无法得到shop_price列的数据，因为sgoods就没有shop_price列</span><br></pre></td></tr></table></figure></li><li><p>简化复杂的查询</p><p><code>select  * from (select ....)</code></p><p>我们可以将内层select语句的查询结果转为视图</p><p>在通过视图查询我们具体想要的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先将所有值查出来</span><br><span class="line">select cat_id,avg(shop_price) as pj from goods group by cat_id;</span><br><span class="line">然后取前三</span><br><span class="line">select * from (select cat_id,avg(shop_price) as pj from goods group by cat_id) as tmp order by pj desc limit 0,3;</span><br><span class="line">使用view简化后查询</span><br><span class="line">create view pingjun as select cat_id,avg(shop_price) as pj from goods group by cat_id;</span><br><span class="line">select * from pingjun order by pj desc limit 0,3;</span><br></pre></td></tr></table></figure></li><li><p>view 是什么？</p><p>view就是你存储好的一条sql的查询结果</p><p><code>select * from pingjun order by pj desc limit 0,3;</code></p><p>这条sql的查询的pingjun这个表，我们不能看出来pingjun是个表还是个视图。</p><p>show   tables；</p><p>可以看到我们的视图，也是存在的，我们都区分不出来它是表还是视图。</p></li><li><p>视图可以更改，删除吗？</p><p>更改物理表，我们发现视图的内容也跟着变化了。</p><p>更改视图，物理表也变化了。</p><p>但有些情况不能改变，如果视图view某一行，是由物理表经过计算得到的结果，view则不能更改，因位它映射到物理表上有多行，不知道更改哪里。比如view上的平均值</p></li></ul></li></ol><h5 id="表-视图管理语句"><a href="#表-视图管理语句" class="headerlink" title="表/视图管理语句"></a>表/视图管理语句</h5><p>show   tables   ：  查看表，视图也会显示出来。</p><p>desc  表/视图    ：查看表结构</p><p>show create table 表   ：查看建表过程语句</p><p>show create view  视图 ：查看建视图过程语句</p><p>drop table  表： 删除表</p><p>drop  view  视图名 ：删除视图</p><p>查看库中的表信息，show table status；</p><p>如果表中信息太多，竖着显示：show table status \G</p><p>查看某张表详细信息：</p><p>show  table status where name=’表名’；</p><p>修改表名：</p><p> rename table oldName to newName;</p><p>清空表数据：</p><p>truncate(相当于删除表，再重建)  表名；</p><p>delete from 表名；</p><p>delete from 表名；删除数据后，再加入新数据，发现id并不是重新开始增长的，而是接着上次的id继续增长。</p><p>truncate 表名；</p><p>清空表的数据；这次我们可以看到id的值，从0开始增长了。</p><h5 id="存储引擎的概念"><a href="#存储引擎的概念" class="headerlink" title="存储引擎的概念"></a>存储引擎的概念</h5><p>数据库对同样的数据，有着不同的存储方式和管理方式。</p><p>在mysql中，称为存储引擎。有myisam 和innoDB两种</p><p>myisam  批量插入的速度更快。但不支持事务安全，支持全文索引，锁机制是表锁。</p><p>innoDB 批量插入的速度稍慢，支持事务安全，不支持全文索引，锁机制是行锁。</p><h5 id="字符集与乱码问题"><a href="#字符集与乱码问题" class="headerlink" title="字符集与乱码问题"></a>字符集与乱码问题</h5><p>乱码：只是文字本来的字符集和展示的字符集不一致。</p><p>解决：输入的字符集和展示的字符集一致。</p><p>选字符集 —&gt;就选择 utf8 即可</p><p>杜绝乱码：</p><ol><li>php 文件ufr8</li><li>html页面的meta信息也是utf8</li><li>建表时，也是utf8</li><li>php页面连接数据库时 set names utf8</li></ol><h4 id="校对集"><a href="#校对集" class="headerlink" title="校对集"></a>校对集</h4><p>charset 是字符集 ，那校对集是什么？</p><p>校对集并不常用，我们知道它的概念即可。</p><p>校对集就是字符集的排序规则，一套字符集可以有n套校对集。</p><p>说白了就是字符串怎么排序，谁排前谁排后。caDB这几个字母按照ascii字符集里，a代表96,大写A是65。但按照人们习惯是aBcD这样排。这就是校对集</p><h5 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h5><p>索引相当于一本书上的目录。索引是数据的目录，能快速定位行数据的位置。</p><p>索引提高了查询速度，降低了增删改的速度，并非加的越多越好。</p><ul><li><p>key普通索引</p><p>纯粹就是帮我们组织数据，提高查询速度。</p></li><li><p>unique key 唯一索引</p></li></ul><p>​        加快查询速度，约束数据。</p><p>​       unique是唯一的，不能重复。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create  table t(name char(10),email char(20),key name(name),unique key email(email));</span><br><span class="line">insert into t22 values (&#39;lisi&#39;,&#39;lisi@qq.com&#39;);</span><br><span class="line">insert into t22 values (&#39;lisi&#39;,&#39;lisi@qq.com&#39;);&#x2F;&#x2F;因为emial是唯一索引，不能重复所以会报错</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>primary key 主键索引</p><p>一张表中，只可能有一个primary key </p></li><li><p>fulltext 全文索引</p><p>中文环境下，全文索引无效。</p><p>因为英文，每个单词是分开的，它将每个单词分门别类，建立索引</p><p>你查这行中的任意一个单词，都有可能查询到这行数据。</p><p>而中文的每个字是连在一起的，它无法区分每个字。所以中文环境下无效</p><p>在中文环境下 , 需要 分词 + 索引才有效<br>一般用第三方解决方案 , 如 sphinx</p></li></ul><p>设置索引长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">建索引时，可以指定索引列的前一部分的内容。比如前10个字符</span><br><span class="line">create table t(</span><br><span class="line">name char(10),</span><br><span class="line">email char(20),</span><br><span class="line">key name(name),</span><br><span class="line">unique email(email(10))</span><br><span class="line">);</span><br><span class="line">误区：给email的前十个字符建立索引，只是为了让查询速度增快。只是速度快了。</span><br></pre></td></tr></table></figure><p>多列索引</p><p>有的时候，一列索引还查询不出来什么效果。</p><p>多列索引，就是把2列或多列的值，看成一个整体，然后建索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table t25 (</span><br><span class="line">xing char(10),</span><br><span class="line">ming char(10),</span><br><span class="line">key xm(xing,ming)</span><br><span class="line">);</span><br><span class="line">显示如何使用索引来处理select语句及连接表</span><br><span class="line">explain select * from t25 where xing&#x3D;&#39;zhang&#39; and ming&#x3D;&#39;san&#39; \G</span><br><span class="line">多列索引，查询数据可以将索引都用上，也可以只用第一个如xing。但用xing之后的索引则</span><br><span class="line">不起作用！</span><br></pre></td></tr></table></figure><h5 id="冗余索引"><a href="#冗余索引" class="headerlink" title="冗余索引"></a>冗余索引</h5><p>就是在某个列上，可能存在多个索引</p><p>比如 xm(xing,ming)我们单查ming，索引不发挥作用。</p><p>给ming也加上索引，单独查ming的时候，也是有索引发挥作用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t26 (</span><br><span class="line">xing char(10),</span><br><span class="line">ming char(10),</span><br><span class="line">key xm(xing,ming),</span><br><span class="line">key ming(ming) &#x2F;&#x2F;给ming也加上索引</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h5><p>查看索引</p><p>show index from 表名</p><p>删除索引</p><p>alter table 表名 drop  index 索引名</p><p>添加索引</p><p>alter table 表名 add index/unique xm(xing,ming);</p><p>添加主键索引</p><p>alter table 表名 add id int not null; //添加id列</p><p>alter table 表名 add primary key (id); //将id列设为主键</p><p>删除主键索引</p><p>alter table 表名 drop primary key;</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>floor(x) 返回小于x的最大整数值</p><p><code>select goods_id,floor(shop_pirce) from goods;</code></p><p>rand() 返回0到1内的随机值，可以通过提供一个参数是rand()随机数生成器生成一个指定值</p><p><code>select floor(5+rand()*5);</code>随机生成5到10随机数</p><p>left(str,x)返回字符串str中最左边的x字符</p><p><code>select left(email,3) from t</code>将t表中email 列中数据值前3个字符</p><p>position(substr in str) 返回资产substr 在字符串str中第一次出现的位置</p><p><code>select left(email,position(&#39;@&#39; in email)-1) from t27;截取@之前的字符</code></p><p>now()返回当前的日期和时间</p><p>select now();</p><p>date_format(date,fmt)依照指定的fmt格式格式化日期date值</p><p>注意要加百分号%</p><p>select date_format(now(),’%y/%m’);</p><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>事务就是在一个业务下的具体多个小的语句，要么让你都完成，要么让你都不完成，从而保证你数据的一个安全性</p><p>innodb支持事务，myisam不支持</p><p>特性：</p><p>原子性：要成功一起成功，要失败一起失败</p><p>一致性：事务发生前和发生后，数据总和一致</p><p>隔离性：操作后，完成前。两者同时完成才能正常操作</p><p>持久性：一旦事务完毕，无法撤销</p><p>开启事务：</p><p>start  transaction</p><p>sql操作</p><p>完成事务：commit</p><p>撤销事务：rollback; 不想执行sql操作了</p><p>不使用事务： sql操作 —-&gt;直接作用表数据</p><p>使用事务：sql操作——–&gt;事务日志，记录下sql操作——-&gt;同时作用于表数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;视图-view&quot;&gt;&lt;a href=&quot;#视图-view&quot; class=&quot;headerlink&quot; title=&quot;视图 view&quot;&gt;&lt;/a&gt;视图 view&lt;/h4&gt;&lt;p&gt;视图说白了就是查询后的结果集，将这个结果集保存起来，方便下次从这个结果集中查询数据。&lt;/p&gt;
&lt;ol
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库表的认识</title>
    <link href="http://yoursite.com/2020/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2020/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E8%AE%A4%E8%AF%86/</id>
    <published>2020-07-27T15:52:05.000Z</published>
    <updated>2020-07-29T09:30:02.071Z</updated>
    
    <content type="html"><![CDATA[<h4 id="table-表的创建"><a href="#table-表的创建" class="headerlink" title="table 表的创建"></a>table 表的创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create  database lianxi charset utf8;&#x2F;&#x2F;创建数据库lianxi  数据库的字符集utf8</span><br><span class="line">use lianxi; &#x2F;&#x2F;使用数据库</span><br><span class="line">create table salary(                &#x2F;&#x2F;创建表salary</span><br><span class="line">name char(4) not null default &#39;&#39;,</span><br><span class="line">gender char(1) not null default &#39;&#39;,</span><br><span class="line">com varchar(20) not null default &#39;&#39;,</span><br><span class="line">money decimal(6,2) not null default 0.00,</span><br><span class="line">fb smallint not null default 0)engine myisam charset utf8;  &#x2F;&#x2F;引擎是myisam  表的字符集是utf8;</span><br></pre></td></tr></table></figure><h5 id="整型列"><a href="#整型列" class="headerlink" title="整型列"></a>整型列</h5><p>mysql中 各种列的类型及特点</p><p>列类型大致分为3类：</p><p>​     整值型：整型，浮点型，定点型（比较精确）</p><p>​     字符串：char , varchar , text</p><p>​     日期时间类型：2012-12-13   14:25:23 </p><p>整型：</p><p>一个字节有8位，每个位上有0,1两种可能</p><p>一个列，占的字节越多，存储的范围越大。</p><p>tinyint               1个字节    -128-127     0-255</p><p>smallint            2个字节     -32768-32767      0-65535</p><p>mediumint      3个字节    -8388608-8388607    0-16777215</p><p>int                     4个字节     -2147483648-2147483647    0-4294967295</p><p>bigint               8个字节     -9223372036854775808-9223372036854775807    0-18446744073709551615</p><p>无符号范围很容易理解就是8位全为0或全为1的值，有符号的呢？在计算机内最高为表示符号0为正，1为负。有符号的其实计算的是后7位的值。</p><h5 id="整型列的可选参数"><a href="#整型列的可选参数" class="headerlink" title="整型列的可选参数"></a>整型列的可选参数</h5><p>unsigned：无符号类型</p><p>zerofill:零填充 默认是无符号类型 如<code>数据类型 int(4) 表示数据应是4位。如果添加的数据只有2位则前面用零补齐</code></p><h5 id="浮点列与定点列"><a href="#浮点列与定点列" class="headerlink" title="浮点列与定点列"></a>浮点列与定点列</h5><p>float 浮点型   <code>float(5,2)5表示精度，总位数，2表示标度，小数点后的位数 如：999.99</code></p><p>double 范围更大的浮点型</p><p>decimal 定点型 更准确 一般用于钱</p><h5 id="字符型列"><a href="#字符型列" class="headerlink" title="字符型列"></a>字符型列</h5><p>char   varchar   text/blob  enum</p><p>char 定长存储内容</p><p>varchar 变长存储内容</p><p>char和varchar区别：</p><p>char(10) 不管字符长度多少，都是存储10个字符的宽度</p><p>varchar(10)最多存储10个字符，用多少占多少。</p><p>char速度更快。适用于固定长或简短的数据</p><p>varchar适用于不定长的数据</p><p>text文本类型：</p><p> 可以存比较大的文本段，搜索速度稍慢。因此如果不是特别大的内容，建议用char,varchar代替</p><p>enum枚举类型：定义好，只能在某几个枚举范围内，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;create table t(gender enum(&#39;boy&#39;,&#39;girl&#39;));&#96;</span><br><span class="line">insert into t values(&#39;boy&#39;);   只能存储boy或girl类型</span><br></pre></td></tr></table></figure><h5 id="日期时间列"><a href="#日期时间列" class="headerlink" title="日期时间列"></a>日期时间列</h5><p>日期时间类型：year  1901-2155</p><p>​                           date    1000/01/01-9999/12/31</p><p>​                           time   -838:59:59-838:59:59</p><p>​                           datetime     1000/01/01 00:00:00-9999:12:31 23:59:59</p><p>​                           时间戳： 1970-01-01 00:00:00 到当前的秒数</p><p>​                           一般存储注册时间，商品发布时间等，并不是用datetime存储，而是用时间戳</p><p>​                            因为datetime虽然直观，但计算不便</p><p>timestamp时间戳  如果我们插入改行，时间戳这列会自动插入当前时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table t(id int,tt timestamp);</span><br><span class="line">timestamp列的显示格式与datetime列相同</span><br></pre></td></tr></table></figure><h6 id="主键与自增"><a href="#主键与自增" class="headerlink" title="主键与自增"></a>主键与自增</h6><p>primary key 能够区分每一行的列，如id</p><p>主键不能重复。</p><p>主键往往和auto_increment一起出现，但并不意味着他们两个必须要绑定在一起使用。</p><p>不声明主键直接使用auto_increment，但必须有索引，才能成功</p><p><code>create table t(id int auto_increment,name char(5),index id(id));</code></p><h5 id="列的删除增加与修改"><a href="#列的删除增加与修改" class="headerlink" title="列的删除增加与修改"></a>列的删除增加与修改</h5><p>alter table 表名 add 列名  列类型  列属性   添加新列</p><p><code>alter table user add height tinyint unsigned not null default 0</code></p><p>alter table 表名  change  旧列名  新列名  新类型  列属性</p><p><code>alter table user change height shengao smallint not null default 0</code></p><p>alter table 表名  modify  列名 新属性    //只修改属性</p><p><code>alter table user modify height tinyint not null default 0</code></p><p>alter table  表名  drop  [column] 列名</p><p><code>alter table user  drop column height</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;table-表的创建&quot;&gt;&lt;a href=&quot;#table-表的创建&quot; class=&quot;headerlink&quot; title=&quot;table 表的创建&quot;&gt;&lt;/a&gt;table 表的创建&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>select查询</title>
    <link href="http://yoursite.com/2020/07/23/select%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2020/07/23/select%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-07-22T23:35:43.000Z</published>
    <updated>2020-07-27T15:45:19.531Z</updated>
    
    <content type="html"><![CDATA[<h4 id="select条件语句"><a href="#select条件语句" class="headerlink" title="select条件语句"></a>select条件语句</h4><p>select 后面不仅能写where 还能写 group by,having,order by,limit等</p><p>投影概念：</p><p> 取出表中的部分列，就叫做投影运算</p><p>如：<code>select name,age from user;</code></p><p>表中两个列做运算，叫做广义投影</p><p>如：<code>select goods_id,marker_price-shop_price from goods;</code></p><h5 id="子查询有严格的顺序的"><a href="#子查询有严格的顺序的" class="headerlink" title="子查询有严格的顺序的"></a>子查询有严格的顺序的</h5><p>where , group by , having , order by , limit</p><h5 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select avg(shop_price) from goods; 平均函数</span><br><span class="line">select sum(goods_number) from goods; 求和</span><br><span class="line">select max(shop_price) from goods;最大值</span><br><span class="line">select min(shop_price) from goods;最小值</span><br><span class="line">select count(*) from goods;计算行数</span><br><span class="line">注意：count是计算行数，它取决于筛选的条件而不是它括号里面的条件</span><br></pre></td></tr></table></figure><h5 id="where子句-条件"><a href="#where子句-条件" class="headerlink" title="where子句 条件"></a>where子句 条件</h5><p>将表的列看成变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in是集合</span><br><span class="line">select * from user where uid in(2,4); 取出uid是2和4的数据</span><br><span class="line">between and 是范围</span><br><span class="line">select * from user where uid berween 2 and 5 ;取出uid在2到5之间的数据</span><br></pre></td></tr></table></figure><p>where型子查询：说白了就是合并的两条查询语句，这就是子查询</p><p>如：<code>select goods_id,goods_name from goods where goods_id in(select max(goods_id) from goods group by cat_id);</code></p><p>通配符：like</p><p> <code>select * from goods where cat_name like &#39;诺基亚%&#39;;</code></p><p>查询 cat_name开头是诺基亚的数据。%代表所有字符</p><p>限制取出条目：limit</p><p>limit offset ,N  跳过offset条，取出N条</p><p><code>select * from goods limit 0,5;</code>    查询goods表前5个数据</p><p>order by一般和limit配合使用，功能才会更强大</p><h5 id="from型子查询-查询的表是临时表"><a href="#from型子查询-查询的表是临时表" class="headerlink" title="from型子查询  查询的表是临时表"></a>from型子查询  查询的表是临时表</h5><p>先select查询出结果集看作一张表，起一个别名，再在外层select这张临时表中的内容。</p><p><code>goods_id,goods_name from (select goods_id,cat_id from goods order by goods_id desc)as tmp group by cat_id;</code></p><h5 id="group-by子句-分组"><a href="#group-by子句-分组" class="headerlink" title="group by子句 分组"></a>group by子句 分组</h5><p>分组查询，一般是比较消耗资源的，因为数据会先按照分组进行排序，再筛选出你所需的内容出来，如果索引建立的比较巧妙，在分组的时候有可能根据索引不需要排序，所以分组计算能避免就避免，它比较浪费资源。</p><p><code>select * from goods group by cat_id;</code>   根据 cat_id  分组</p><h5 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h5><p>as 相当于 = 号</p><p>where 和 having  不同是 where在执行前作用于表，having查询结果后再执行</p><p>如果语句里where和having都存在，where 要放在 having 的前面</p><h5 id="order-by-子句-排序"><a href="#order-by-子句-排序" class="headerlink" title="order by 子句 排序"></a>order by 子句 排序</h5><p><code>select goods_id,goods_name,shop_price from goods order by shop_price desc</code></p><p>通过shop_price排序   desc 倒序排序   asc 正序排序</p><h5 id="exists型子查询"><a href="#exists型子查询" class="headerlink" title="exists型子查询"></a>exists型子查询</h5><p>可以代替 in 查询，且效率更高</p><p>exists相当于判断语句，如果exists后面成立，则取出结果</p><p><code>select * from category where exists (select * from goods where category.cat_id=goods.cat_id);</code></p><p>查询的还是category表，条件是goods中cat_id和category表中的cat_id得相等</p><h5 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h5><p><code>inner join.....on</code>   取两张表的交集</p><p><code>select boy.hid,boy.bname,girl.hid,girl.gname from boy inner join girl on boy.hid=girl.hid;</code></p><h5 id="左连接及右连接查询"><a href="#左连接及右连接查询" class="headerlink" title="左连接及右连接查询"></a>左连接及右连接查询</h5><p>左连接和右连接类似，只是调个方向。</p><p><code>left  join .....on</code> 以左边为主，取出左边所有数据，让右边数据去匹配，没有的以 NULL 补齐</p><p><code>select boy.hid,boy.bname,girl.hid,girl.gname from boy left join girl on boy.hid=girl.hid;</code></p><h5 id="union查询"><a href="#union查询" class="headerlink" title="union查询"></a>union查询</h5><p>就是把2条或多条sql的查询结果，合并成1个结果集。</p><p>sql1 返回n行</p><p>sql2 返回m行</p><p>sql1 union sql2 返回n+m行</p><p>注意：union语句必须满足 1个条件，各语句取出的列数相同。列名未必一致，查询出的结果列名称会使用第一条sql的列名为准。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select uid,name,age from user</span><br><span class="line">union</span><br><span class="line">select id,title,time from tmp;</span><br><span class="line">查询出的结果是俩表的数据，但是列名是uid,name,age;</span><br></pre></td></tr></table></figure><p>使用union时，完全相等的行，将会被合并，合并是比较耗时的操作，两行会在比较看是否完全相等。一般不让union进行合并，使用 union all 可以避免</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;select条件语句&quot;&gt;&lt;a href=&quot;#select条件语句&quot; class=&quot;headerlink&quot; title=&quot;select条件语句&quot;&gt;&lt;/a&gt;select条件语句&lt;/h4&gt;&lt;p&gt;select 后面不仅能写where 还能写 group by,having
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库简识</title>
    <link href="http://yoursite.com/2020/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E8%AF%86/"/>
    <id>http://yoursite.com/2020/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E8%AF%86/</id>
    <published>2020-07-20T16:19:05.000Z</published>
    <updated>2020-07-22T23:30:14.702Z</updated>
    
    <content type="html"><![CDATA[<h5 id="数据库初识"><a href="#数据库初识" class="headerlink" title="数据库初识"></a>数据库初识</h5><p>何为数据库？就是管理数据的一个软件，数据库好比是一本书，数据相当于书里的目录，有文章，有作者等信息。它能帮我们很好的管理这些数据，而且效率很高。这就是数据库。</p><h5 id="表与库的概念"><a href="#表与库的概念" class="headerlink" title="表与库的概念"></a>表与库的概念</h5><p>数据库是通过表来管理数据，数据库可以有多张表。而服务器可以帮我们管理多个库。</p><p>查看库：<code>showdatabases</code></p><p>选库：<code>use test</code>  test是库名</p><p>查看库下的表：<code>show tables</code></p><p>查表：<code>select  *  from cat</code> cat是表名</p><h5 id="认识sql"><a href="#认识sql" class="headerlink" title="认识sql"></a>认识sql</h5><p>sql是一门标准的计算机语言，用来访问和操作数据库系统</p><p>sql分为两部分，数据操作语言 DML 和 数据定义语言 DDL</p><p>DML就是表的操作：insert 、delete、update、select</p><p>DDL就是数据库和表的操作：</p><p>​                           create database 创建数据库</p><p>​                           alter  database 修改数据库</p><p>​                            create  table 创建表</p><p>​                           alter table   修改表</p><p>​                            drop table 删除表</p><p>​                             create index  创建索引</p><p>​                            drop  index  删除索引</p><h6 id="DML增删改查"><a href="#DML增删改查" class="headerlink" title="DML增删改查"></a>DML增删改查</h6><p> insert 操作：列与值，必须严格对应</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(列名)values(值);</span><br><span class="line">insert into user(uid,name,age) values(1,&#39;wangwu&#39;,23);</span><br><span class="line">插入多条数据：</span><br><span class="line">insert into user values(1,&#39;lisi&#39;,22),(2,&#39;lisi2&#39;,23),(3,&#39;lisi3&#39;,24);</span><br></pre></td></tr></table></figure><p>update 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 列&#x3D;值 where 条件</span><br><span class="line">update user set age&#x3D;24 where name&#x3D;&#39;lisi&#39;;</span><br></pre></td></tr></table></figure><p>delete 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where 条件</span><br><span class="line">delete from user where name&#x3D;&#39;lisi&#39;;</span><br></pre></td></tr></table></figure><p>select  操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 列名 from 表名  where 条件</span><br><span class="line">select name,age from user where uid&#x3D;1;</span><br></pre></td></tr></table></figure><p>​       </p><p>​      </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;数据库初识&quot;&gt;&lt;a href=&quot;#数据库初识&quot; class=&quot;headerlink&quot; title=&quot;数据库初识&quot;&gt;&lt;/a&gt;数据库初识&lt;/h5&gt;&lt;p&gt;何为数据库？就是管理数据的一个软件，数据库好比是一本书，数据相当于书里的目录，有文章，有作者等信息。它能帮我们很好的
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql编译安装</title>
    <link href="http://yoursite.com/2020/06/28/mysql%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/06/28/mysql%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</id>
    <published>2020-06-28T08:51:39.000Z</published>
    <updated>2020-06-30T08:50:59.573Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><h4 id="使用二进制文件在linux上安装MySQL"><a href="#使用二进制文件在linux上安装MySQL" class="headerlink" title="使用二进制文件在linux上安装MySQL"></a>使用二进制文件在linux上安装MySQL</h4><ol><li><p>下载二进制版本安装</p><p><code>http://mirrors.sohu.com/mysql/MySQL-5.5/</code> </p></li><li><p>解压</p><p><code>tar  -zxf   mysql-5.5.61-linux-glibc2.12-i686.tar.gz</code></p></li><li><p>一般二进制文件都有安装说明</p><p>进入解压后的 mysql 文件，会看到 INSTALL-BINARY 文件 ，more   INSTALL-BINARY  查看文件</p></li><li><p>检测是否安装libaio库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum  search   libaio </span><br><span class="line">yum  install  libaio</span><br></pre></td></tr></table></figure></li><li><p>建立用户和组</p><ul><li>建立用户组  <code>groupadd  mysql</code></li></ul><ul><li>建立用户      <code>useradd -r -g mysql mysql</code></li><li>cd到mysql   <code>cd mysql</code></li><li>将文件用户改为mysql <code>chown -R mysql .</code></li><li>将文件组改为mysql <code>chgrp -R mysql .</code></li><li>初始化 <code>scripts /mysql_install_db  --user=mysql</code></li><li>将文件用户改为root <code>chown -R root .</code></li><li>将data改为用户mysql <code>chown -R mysal data</code></li></ul></li><li><p>启动</p><p><code>./bin/mysqld_safe --user=mysql &amp;</code></p></li><li><p>可能会出现的问题</p><p><code>[ERROR] Can’t start server: can’t create PID filepath: No such file or directory</code></p><p>错误原因：一般由于服务器强制关机导致pid文件丢失</p><p>解决：在/etc/my.cnf中查看pid-file的位置发现没有mysqld，则创建文件</p><p><code>mkdir  ./mysqld</code></p><p>将 mysqld 文件所属用户改为mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown mysql &#x2F;var&#x2F;run&#x2F;mysqld -R</span><br><span class="line">chgrp mysql &#x2F;var&#x2F;run&#x2F;mysqld -R</span><br></pre></td></tr></table></figure></li><li><p>进入mysql</p><p>./bin/mysql</p></li></ol><p>​      提示：找不到sock文件</p><p>​     创建快捷方式  <code>ln /var/lib/mysql/mysql.sock  /tmp/msyql.sock</code></p><h5 id="修改-MySQL密码"><a href="#修改-MySQL密码" class="headerlink" title="修改 MySQL密码"></a>修改 MySQL密码</h5><p>  进入mysql  :   ./bin/mysql</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show databases;&#x2F;&#x2F;显示数据库</span><br><span class="line">use mysql; &#x2F;&#x2F;进入msyql数据库</span><br><span class="line">show tables;&#x2F;&#x2F;mysql数据库下的表</span><br><span class="line">desc user;&#x2F;&#x2F;user表详细信息</span><br><span class="line">select host，user，password  from user;&#x2F;&#x2F;列出user表的三个相关字段</span><br><span class="line">update user set Password&#x3D;password(&#39;123456&#39;) where Host&#x3D;&#39;localhost&#39; and User&#x3D;&#39;root&#39;;&#x2F;&#x2F;修改密码</span><br><span class="line">delete from user where Password&#x3D;&#39;&#39;;&#x2F;&#x2F;删除空密码的账号</span><br><span class="line">flush privileges;&#x2F;&#x2F;刷新</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;mysql&quot;&gt;&lt;a href=&quot;#mysql&quot; class=&quot;headerlink&quot; title=&quot;mysql&quot;&gt;&lt;/a&gt;mysql&lt;/h4&gt;&lt;h4 id=&quot;使用二进制文件在linux上安装MySQL&quot;&gt;&lt;a href=&quot;#使用二进制文件在linux上安装MySQ
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx+php整合</title>
    <link href="http://yoursite.com/2020/06/27/nginx-php%E6%95%B4%E5%90%88/"/>
    <id>http://yoursite.com/2020/06/27/nginx-php%E6%95%B4%E5%90%88/</id>
    <published>2020-06-27T08:34:47.000Z</published>
    <updated>2020-06-27T08:50:43.180Z</updated>
    
    <content type="html"><![CDATA[<h4 id="php的安装和编译"><a href="#php的安装和编译" class="headerlink" title="php的安装和编译"></a>php的安装和编译</h4><ol><li>php安装前期准备</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gd zlib zlib-devel openssl openssl-devel libxml2 libxml2-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel</span><br></pre></td></tr></table></figure><ol start="2"><li><p>到官网下载对应的php版本</p><p>解压php</p></li><li><p>配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php \</span><br><span class="line">--with-gd \</span><br><span class="line">--enable-gd-native-ttf \</span><br><span class="line">--enable-mysqlnd \</span><br><span class="line">--with-mysql&#x3D;mysqlnd \</span><br><span class="line">--with-pdo-mysql&#x3D;mysqlnd \</span><br><span class="line">--with-openssl \</span><br><span class="line">--enable-mbstring \</span><br><span class="line">--with-jpeg-dir\</span><br><span class="line">--with-freetype-dir \</span><br><span class="line">--enable-fpm</span><br></pre></td></tr></table></figure><p>如果报警告   <code>--with-*** 是因为当前php版本不支持</code></p></li></ol><p>4.安装编译</p><p>  <code>make &amp;&amp; make install</code></p><p>5.启动</p><p><code>./sbin/php-fpm</code></p><p>启动失败: /etc下找不到php-fpm.conf文件导致</p><p>解决办法：<code>cp etc/php-fpm.conf.default etc/php-fpm.conf</code></p><h4 id="php-nginx整合"><a href="#php-nginx整合" class="headerlink" title="php+nginx整合"></a>php+nginx整合</h4><p>访问php文件时，需要设置nginx配置文件nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local~\.php$&#123;</span><br><span class="line">  root          html;</span><br><span class="line"> fastcgi_pass   127.0.0.1:9000;  &#x2F;&#x2F;主机地址9000是php的端口</span><br><span class="line"> fastcgi_index  index.php</span><br><span class="line"> fastcgi_param  SCRIPT_FILENAME $DOCUMENT_ROOT$fastcgi_script_name; &#x2F;&#x2F;php地址</span><br><span class="line"> include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>./sbin/nginx -s reload   配置文件生效</p><p>可以访问了但是，发现缺少ini，找到解压后php-5.6.38文件将php.ini-复制过去</p><p><code>cp /usr/local/php-5.6.38/php.ini-development  /usr/local/php/lib/php.ini</code></p><p>至此php+nginx完成整合！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;php的安装和编译&quot;&gt;&lt;a href=&quot;#php的安装和编译&quot; class=&quot;headerlink&quot; title=&quot;php的安装和编译&quot;&gt;&lt;/a&gt;php的安装和编译&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;php安装前期准备&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx的pathInfo和重写</title>
    <link href="http://yoursite.com/2020/06/23/nginx%E7%9A%84pathInfo%E5%92%8C%E9%87%8D%E5%86%99/"/>
    <id>http://yoursite.com/2020/06/23/nginx%E7%9A%84pathInfo%E5%92%8C%E9%87%8D%E5%86%99/</id>
    <published>2020-06-23T01:11:42.000Z</published>
    <updated>2020-06-23T01:40:03.166Z</updated>
    
    <content type="html"><![CDATA[<h4 id="pathInfo"><a href="#pathInfo" class="headerlink" title="pathInfo"></a>pathInfo</h4><p>何为pathInfo?看下面这个网址</p><p><a href="http://localhost/index.php/Home/Index" target="_blank" rel="noopener">http://localhost/index.php/Home/Index</a></p><p>本该到index.php就结束了但后面还跟了Home/Index 。而Home/Index就是pathInfo实现的功能，不少php框架都有此模式。</p><p>nginx默认是不支持pathInfo的，需要手动设置参数，修改conf 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location  ~ \.php(.*)$&#123;</span><br><span class="line">  ...</span><br><span class="line">  fascgi_param PATH_INFO  $1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h4><p>显示页面指定到某个php或html，但不想在浏览器地址栏显示 .php或 .html 。这就用到了重写</p><p>nginx重写有 rewrite 方式和 try_files 方式 。rewrite方式太麻烦我们就只介绍try_files方式 。修改conf 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;去掉 path_info</span><br><span class="line">location &#x2F;&#123;</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line">  try_files $uri  &#x2F;index.php?$uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> $uri  是<a href="http://localhost/index.php?auto/login" target="_blank" rel="noopener">http://localhost/index.php?auto/login</a> 中的 auto/login</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;pathInfo&quot;&gt;&lt;a href=&quot;#pathInfo&quot; class=&quot;headerlink&quot; title=&quot;pathInfo&quot;&gt;&lt;/a&gt;pathInfo&lt;/h4&gt;&lt;p&gt;何为pathInfo?看下面这个网址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://loca
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx配置</title>
    <link href="http://yoursite.com/2020/06/22/nginx%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/06/22/nginx%E9%85%8D%E7%BD%AE/</id>
    <published>2020-06-22T00:56:10.000Z</published>
    <updated>2020-06-22T14:08:06.675Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx配置虚拟主机"><a href="#nginx配置虚拟主机" class="headerlink" title="nginx配置虚拟主机"></a>nginx配置虚拟主机</h4><p>在conf文件里，一个server就是一个虚拟主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name ddd.com; &#x2F;&#x2F;域名</span><br><span class="line"> location &#x2F;&#123;</span><br><span class="line">  root  html&#x2F;ddd; &#x2F;&#x2F;网站站点目录</span><br><span class="line">  index  index.php  index.html;  &#x2F;&#x2F;网站首页</span><br><span class="line"> &#125;</span><br><span class="line"> location ~\.php$&#123; &#x2F;&#x2F;php结尾的文件</span><br><span class="line">  root  html&#x2F;ddd; &#x2F;&#x2F;站点目录</span><br><span class="line">  fastcgi_pass  127.0.0.1:9000; &#x2F;&#x2F;ip地址 php程序是9000端口</span><br><span class="line">  fastcgi_index  index.php; &#x2F;&#x2F;首页</span><br><span class="line">  fastcgi_param  SCRIPT_FILENAME $DOCUMENT_ROOT$... &#x2F;&#x2F;php会去这个站点目录运行脚本</span><br><span class="line">  include fastcgi_params;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h4><p>日志内容大致为：</p><p>访问者ip    访问时间     请求行    200     访问的字节长度     浏览器类别</p><p>conf文件有日志格式：</p><p>simple 是日志名称</p><p> log_format  simple  “ “</p><p>给项目设置独立日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name  ddd.com;</span><br><span class="line"> access_log  logs&#x2F;ddd.log  simple;</span><br><span class="line"> localtion ~&#x2F;.php$&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;nginx配置虚拟主机&quot;&gt;&lt;a href=&quot;#nginx配置虚拟主机&quot; class=&quot;headerlink&quot; title=&quot;nginx配置虚拟主机&quot;&gt;&lt;/a&gt;nginx配置虚拟主机&lt;/h4&gt;&lt;p&gt;在conf文件里，一个server就是一个虚拟主机&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx服务器</title>
    <link href="http://yoursite.com/2020/06/22/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2020/06/22/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-06-22T00:18:32.000Z</published>
    <updated>2020-06-22T00:55:07.509Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx是什么？"><a href="#nginx是什么？" class="headerlink" title="nginx是什么？"></a>nginx是什么？</h4><p>nginx是一款轻量级的web 服务器/反向代理服务器及电子邮件代理服务器！</p><p>最早由俄罗斯程序设计师 lgor Sysoev所开发，并在一个BSD-like 协议下发行</p><p>nginx 轻量级，占有内存少，并发能力强，发展势头强劲。因而web领域最经典的lamp组合变成了lnmp组合</p><h4 id="nginx编译安装"><a href="#nginx编译安装" class="headerlink" title="nginx编译安装"></a>nginx编译安装</h4><p>到nginx官网，选择stable版本下载</p><p>nginx依赖于pcre库，所以先下载pcre</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nginx</span><br><span class="line">.&#x2F;configure  --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre-8.39</span><br><span class="line">make  &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>启动：./sbin/nginx</p><h5 id="nginx-目录"><a href="#nginx-目录" class="headerlink" title="nginx 目录"></a>nginx 目录</h5><ul><li>conf   配置文件</li><li>html  网页文件</li><li>logs  日志文件</li><li>sbin  主要二进制程序</li></ul><h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><p>有时候启动nginx会失败，查看端口</p><p>ps  aux|grep  nginx</p><p>80端口容易被占用，一般是防火墙关掉防火墙</p><p><code>servcie iptables stop</code></p><h4 id="nginx-命令"><a href="#nginx-命令" class="headerlink" title="nginx 命令"></a>nginx 命令</h4><ul><li>./sbin/nginx -t  配置文件是否成功</li><li>./sbin/nginx  -s  reload  加载最新配置</li><li>./sbin/nginx -s stop  立即停止</li><li>./sbin/nginx -s quit  优雅停止，执行完程序后停止</li><li>./sbin/nignx  -s  reopen  重新打开日志（当备份了日志文件后，日志内容不往新文件写入就需要重新打开)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;nginx是什么？&quot;&gt;&lt;a href=&quot;#nginx是什么？&quot; class=&quot;headerlink&quot; title=&quot;nginx是什么？&quot;&gt;&lt;/a&gt;nginx是什么？&lt;/h4&gt;&lt;p&gt;nginx是一款轻量级的web 服务器/反向代理服务器及电子邮件代理服务器！&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>linux进程</title>
    <link href="http://yoursite.com/2020/06/20/linux%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/06/20/linux%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-06-20T01:06:12.000Z</published>
    <updated>2020-06-20T01:24:08.684Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>程序是什么？程序其实就是动作指令的集合，而执行程序的过程就是进程！</p><p>查看进程：<code>ps -Af</code></p><a id="more"></a><p>终止进程：<code>kill 程序 id 号</code></p><p>动态查看进程：top</p><p>kill 默认模式是15 终止进程</p><p>kill  -9  pid 是强制终止进程</p><p>pkill 有选择性的向一个或一批进程发送信号</p><p>pkill  程序名</p><p>pkill -u stu 终止stu用户下的一切进程</p><p>守护进程：后台运行随时等待指令，通指系统进程</p><p>chkconfig  –list 查看系统服务</p><p>chkconfig  –list|grep httpd    查询httpd服务进程</p><p>启动服务：service httpd start</p><p>查询服务状态： service httpd status</p><p>停止服务：service httpd stop</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h4&gt;&lt;p&gt;程序是什么？程序其实就是动作指令的集合，而执行程序的过程就是进程！&lt;/p&gt;
&lt;p&gt;查看进程：&lt;code&gt;ps -Af&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
</feed>
